{"version":3,"sources":["redux/store/view.ts","types/core.ts","redux/actions/index.ts","lib/RelationEngineAPIClient.ts","types/transform.ts","redux/reducers/index.ts","redux/store/index.ts","lib/DB.ts","landingPages/taxonomy/lib/model.ts","landingPages/taxonomy/lib/TaxonAPIClient.ts","landingPages/taxonomy/main/TaxonDB.ts","landingPages/taxonomy/SourceInfo.tsx","landingPages/taxonomy/TaxonItem.tsx","landingPages/taxonomy/taxonChildren/TaxonChildrenDB.ts","landingPages/taxonomy/TaxonList.tsx","components/ErrorView.tsx","landingPages/taxonomy/taxonChildren/TaxonChildren.tsx","landingPages/taxonomy/taxonChildren/data.tsx","landingPages/taxonomy/taxonChildren/index.ts","landingPages/taxonomy/lineage/LineageDB.ts","landingPages/taxonomy/lineage/Lineage.tsx","landingPages/taxonomy/lineage/data.tsx","landingPages/taxonomy/lineage/index.ts","landingPages/taxonomy/LineageNavigator.tsx","landingPages/taxonomy/TaxonSummary.tsx","landingPages/taxonomy/taxonInfo/TaxonDetailNCBI.tsx","landingPages/taxonomy/taxonInfo/TaxonDetail.tsx","landingPages/taxonomy/lib/props.ts","components/Wikipedia.tsx","landingPages/taxonomy/lib/Wikipedia.ts","components/Loading.tsx","lib/DB2.ts","landingPages/taxonomy/taxonInfo/TaxonDescription.tsx","landingPages/taxonomy/taxonInfo/linkedData/LinkedDataDB.ts","landingPages/taxonomy/taxonInfo/linkedData/view.tsx","landingPages/taxonomy/taxonInfo/linkedData/data.tsx","landingPages/taxonomy/taxonInfo/linkedData/index.ts","landingPages/taxonomy/taxonInfo/TaxonInfo.tsx","landingPages/taxonomy/main/Taxonomy.tsx","landingPages/taxonomy/main/data.tsx","landingPages/taxonomy/main/index.ts","landingPages/taxonomy/index.ts","types/ontology.ts","landingPages/ontology/lib/OntologyAPIClient.ts","landingPages/ontology/lib/model.ts","landingPages/ontology/Main/OntologyDB.ts","landingPages/ontology/TermLink.tsx","landingPages/ontology/Detail/LinkedObjects/LinkedObjectsDB.ts","landingPages/ontology/Detail/LinkedObjects/view.tsx","landingPages/ontology/Detail/LinkedObjects/data.tsx","landingPages/ontology/Detail/LinkedObjects/index.ts","landingPages/ontology/Children/ChildrenDB.ts","landingPages/ontology/Children/view.tsx","landingPages/ontology/Children/data.tsx","landingPages/ontology/Children/index.ts","landingPages/ontology/AncestorGraph/AncestorGraphDB.ts","landingPages/ontology/AncestorGraph/NetworkGraph.tsx","landingPages/ontology/AncestorGraph/view.tsx","landingPages/ontology/AncestorGraph/data.tsx","landingPages/ontology/AncestorGraph/index.ts","landingPages/ontology/Detail/index.tsx","landingPages/ontology/Main/SourceInfo.tsx","landingPages/ontology/Main/TermSummary.tsx","landingPages/ontology/Main/view.tsx","landingPages/ontology/Main/data.tsx","landingPages/ontology/Main/index.ts","landingPages/ontology/index.ts","components/dispatcher/Dispatcher.tsx","components/dispatcher/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["SyncViewStatus","AsyncViewStatus","ViewType","RelationEngineCategory","RelationEngineDataSource","AppActions","RelationEngineAPIClient","this","get","dataSource","path","console","log","params","url","join","axios","headers","Accept","result","data","stringToNamespace","s","includes","Error","stringToRelationEngineRef","relationEngineID","categoryString","timestamp","split","namespaceString","id","timestampString","core","GO","ENVO","NCBI","GTDB","RDP","relationEngineNamespaceToDataSource","category","TAXONOMY","ONTOLOGY","stringToRelationEngineCategory","Date","now","parseInt","relationEngineReferenceToNamespace","ref","navigateSuccess","navigation","type","NAVIGATE_SUCCESS","navigate","dispatch","getState","a","NAVIGATE_START","userAuthorization","auth","app","config","services","RelationEngine","reClient","token","timeout","ns","namespace","dataSourceInfo","data_source","relationEngineRef","error","message","NAVIGATE_ERROR","state","action","trigger","RelationEngineNodeType","ViewStatus","reducer","baseState","baseReducer","makeInitialStoreState","makeBaseStoreState","NONE","view","status","DBStatus","WorkspaceType","DB","props","db","stopped","onUpdate","initialData","updateFun","forceComponentUpdate","TaxonomyAPIClient","ts","callFunc","offset","limit","searchTerm","search_text","taxon_ns","taxon_id","DynamicServiceClient","module","TaxonomyModel","taxonomyClient","TaxonAPIClient","taxonRef","getLineage","taxons","results","map","taxonResult","isBiological","scientific_name","name","rank","ncbiID","NCBI_taxon_id","geneticCode","gencode","aliases","options","getChildren","taxa","total_count","getTaxon","taxon","getAssociatedWorkspaceObjects","linkedObjects","workspaceType","title","ws_obj","workspace","narr_name","NARRATIVE","refdata_source","REFDATA","UNKNOWN","linkedAt","edge","updated_at","objectID","object_id","workspaceID","workspace_id","version","objectName","createdAt","epoch","workspaceUpdatedAt","module_name","type_name","majorVersion","maj_ver","minorVersion","min_ver","totalCount","TaxonDB","set","LOADING","client","ServiceWizard","LOADED","targetTaxon","selectedTaxon","ERROR","code","source","SourceInfo","className","src","style","height","alt","width","href","target","rel","React","Component","TaxonItem","hovering","selectTaxonRef","hash","String","window","parent","location","ev","setState","Fragment","onClick","clickNavigateToTaxon","bind","clickTaxon","isActive","renderActive","renderOver","renderNormal","classNames","push","tooltipTitle","borderBottom","placement","key","onMouseEnter","onMouseLeave","renderItem","TaxonChildrenDB","serviceWizardURL","page","pageSize","RELOADING","total","TaxonList","navigateToTaxonRef","index","selectedTaxonRef","selectTaxon","navigateToTaxon","description","image","PRESENTED_IMAGE_SIMPLE","length","renderNoItems","renderItemsPlain","ErrorView","color","renderMessage","TaxonChildren","fetchChildren","Intl","NumberFormat","useGrouping","format","currentItem","lastItem","size","renderTitleLoaded","renderTitleReLoading","term","disabled","marginBottom","Search","placeholder","onSearch","doSearch","totalItems","maxItems","tip","renderTaxaLoaded","renderTaxaNone","renderTaxaLoading","renderTaxaReLoading","renderTaxaError","showLessItems","hideOnSinglePage","defaultPageSize","current","onChange","changePage","renderPaginationNone","renderPaginationLoading","renderPaginationError","renderPaginationLoaded","renderPaginationReLoading","renderTitle","renderSearch","renderPagination","renderTaxa","renderChildren","Data","forceUpdate","renderError","renderSuccess","connect","DataComponent","LineageDB","lineage","Lineage","renderLoading","renderLoaded","LineageNavigator","count","selectedRef","overflowY","renderLineage","renderTargetTaxon","TaxonSummary","nameStyle","fontStyle","geneticCodesMap","geneticCodes","Array","ensureGeneticCodes","reduce","label","Map","TaxonDetailNCBI","stringSorter","b","fixedA","replace","fixedB","localeCompare","pagination","scroll","y","rowKey","bordered","Column","dataIndex","defaultSortOrder","sorter","renderAliases","renderTaxonDetail","TaxonDetail","getProp","obj","propPath","defaultValue","TypeError","temp","i","undefined","AsyncComponentLoadingState","NotFound","WIKIPEDIA_API_URL","Wikipedia","proposedTerm","chars","validChar","filter","char","exec","lookupTerm","scrubTerm","getWikipediaInfo","then","imageUrl","pageUrl","introText","pageId","matchingTerms","exactMatch","getPage","wikiResponse","Promise","all","getImage","parse","pageid","getPageInfo","pageInfo","terms","resolve","reject","fetchPage","apiUrl","URL","query","searchParams","fetch","toString","method","accept","json","pop","ex","catch","err","apiURL","Loading","DBCollectionStatus","wikipediaClient","canceled","WikipediaClient","wikipediaInfo","content","marked","overflow","dangerouslySetInnerHTML","__html","fontSize","textAlign","display","flexDirection","flex","renderMatch","alignSelf","marginLeft","renderWikipediaLogoCredit","paddingRight","marginRight","renderArticle","renderImage","findTerm","updateInfo","renderWikipediaInfo","renderNone","TaxonDescription","renderTaxonDescription","notBiological","SortDirection","AsyncTask","taskFun","hasResult","LinkedDataDB","currentTask","cancel","task","getLinkedObjects","linkedObjectsCollection","newTask","run","isCanceled","sort","LinkedData","setPage","filters","column","sortColumn","sortDirection","direction","ASCENDING","DESCENDING","stringToSortDirection","order","updateView","previousProps","isLoading","linkedObject","position","loading","onChangeTable","render","typeID","headerStyle","tooltip","DateTimeFormat","collection","renderLinkedObjects","lastTaxonRef","fetchLinkedObjects","queryLinkedObjects","TaxonInfo","defaultActiveKey","animated","TabPane","tab","forceRender","Taxonomy","setTitle","span","navigateToTaxonREf","renderTaxonInfo","currentlyNavigatedTaxonRef","getSelectedTaxon","margin","getTargetTaxon","sendTitle","OntologySource","OntologyRelation","GOSynonymScope","ownProps","relationEngineId","OntologyAPIClient","termNodeToTerm","stringToOntologyNamespace","comments","definition","def","val","goID","isObsolete","synonyms","exact","synonym","pred","narrow","broad","related","stringToTermRelation","relationString","IS_A","PART_OF","HAS_PART","REGULATES","POSITIVELY_REGULATES","NEGATIVELY_REGULATES","OCCURS_IN","ENDS_DURING","HAPPENS_DURING","relationToString","relation","relatedTermToTerm","relatedTerm","ontologyReferenceToNamespace","OntologyModel","ontologyClient","getTerms","ids","getParents","item","getAssociatedWSObjects","features","forEach","genomeWithFeatures","feature","featureID","feature_id","relatedAt","objectRef","getHierarchicalAncestors","relations","some","r","from","to","relationsMap","m","nodes","has","isRoot","termsGraph","values","OntologyDB","termRef","getTerm","targetTerm","selectedTerm","TermLink","newWindow","renderGOLink","LinkedObjectsDB","getRelatedFeatures","LinkedObjects","row","origin","search","renderTable","ParentsDB","OntologyList","renderRelation","renderItemsTable","currentlyNavigatedOntologyRef","getChildrenTerms","AncestorGraphDB","getAncestorGraph","node","graph","NetworkGraph","networkGraphNode","graphNode","network","createRef","DataSet","add","isTerm","border","shape","edges","e","arrows","layout","hierarchical","enabled","sortMethod","nodeSpacing","physics","highlight","background","top","right","bottom","left","Network","on","nodeID","selectNodeID","selectedNodeID","selectNodes","mountGraph","addEventListener","onResize","graphHeight","clientHeight","setSize","redraw","AncestorGraph","termNode","rowSelection","fixed","hideDefaultSelections","selectedRowKeys","cursor","selectGraphNode","isSelected","Detail","comment","index2","renderComments","renderAllSynonyms","renderSynonyms","Children","tabs","component","renderGraph","renderDetail","justifyContent","TermSummary","OntologyView","renderLayout","setSelectedTerm","selectTerm","navigateToTerm","getTargetTerm","Main","Dispatcher","rootState","RootState","HOSTED","DEVELOP","renderNavigationNone","renderNavigationSome","newURL","parseHash","renderRootState","renderNavigation","renderUnauthorized","root","store","createStore","compose","applyMiddleware","thunk","App","storeUnsubscribe","last","subscribe","runtime","Object","keys","required","Boolean","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.572d6642.chunk.js","sourcesContent":["import { RelationEngineReference } from \"../../types/core\";\nimport { UIError } from '../../types/error';\nimport { TaxonomyView } from \"./taxonomy\";\nimport { OntologyView } from \"./ontology\";\n\n// VIEW STATES\n\n/*\n Sync view state\n Primarily for top level views which don't have an async load operation.\n*/\n\nexport enum SyncViewStatus {\n    NONE,\n    LOADED,\n    ERROR\n}\n\nexport interface SyncViewNone {\n    status: SyncViewStatus.NONE;\n}\n\nexport interface SyncViewError<E> {\n    status: SyncViewStatus.ERROR;\n    error: E;\n}\n\nexport interface SyncViewLoaded<S> {\n    status: SyncViewStatus.LOADED;\n    state: S;\n}\nexport type SyncView<S, E> = SyncViewNone | SyncViewLoaded<S> | SyncViewError<E>;\n\n/*\nAsync view state\nFor any component which requires loading.\n*/\n\n// export interface AsyncViewNone<T> {\n//     status: AsyncViewStatus.NONE;\n//     type: T;\n// }\n\n// export interface AsyncViewLoading<T> {\n//     status: AsyncViewStatus.LOADING;\n//     type: T;\n// }\n\n// export interface AsyncViewError<T> {\n//     status: AsyncViewStatus.ERROR;\n//     error: string;\n//     type: T;\n// }\n\n// export interface AsyncViewLoaded<T, S> {\n//     status: AsyncViewStatus.LOADED;\n//     type: T;\n//     state: S;\n// }\n\n// export type AsyncView<T, S> = AsyncViewNone<T> | AsyncViewLoading<T> | AsyncViewLoaded<T, S> | AsyncViewError<T>;\n\n\n// And the specific landing page views\n\nexport enum AsyncViewStatus {\n    NONE,\n    LOADING,\n    LOADED,\n    ERROR\n}\n\nexport interface AsyncViewNone<> {\n    status: AsyncViewStatus.NONE;\n}\n\nexport interface AsyncViewLoading<> {\n    status: AsyncViewStatus.LOADING;\n}\n\nexport interface AsyncViewError<E> {\n    status: AsyncViewStatus.ERROR;\n    error: E;\n}\n\nexport interface AsyncViewLoaded<S> {\n    status: AsyncViewStatus.LOADED;\n    state: S;\n}\n\nexport type AsyncView<S, E> = AsyncViewNone | AsyncViewLoading | AsyncViewLoaded<S> | AsyncViewError<E>;\n\n/*\nThe view base is the wrapper for all landing page views.\nIt's purpose is to provide an anchor for the view, regardless of what happens in that view\n(which is to be found in the \"state\" property)\n*/\n\nexport enum ViewType {\n    NONE,\n    TAXONOMY,\n    ONTOLOGY\n}\n\n// export interface ViewBase<S> {\n//     type: ViewType;\n//     ref: RelationEngineReference;\n//     state: AsyncView<TopLevelViewState, UIError>\n// }\n\nexport interface ViewBase<S> {\n    type: ViewType;\n    ref: RelationEngineReference;\n    state: AsyncView<S, UIError>\n}\n\n/*\n    The top level view.\n    Each top level view is a generic interface with some fixed properties.\n*/\n\n// export type MainView = ViewBase<TaxonomyView> | ViewBase<OntologyView> | null;\n\nexport type MainView = AsyncView<TaxonomyView, UIError> | AsyncView<OntologyView, UIError>;\n\nexport interface TopLevelViewStateBase {\n    type: ViewType;\n    ref: RelationEngineReference;\n    view: MainView;\n}\n\nexport interface TopLevelViewStateTaxonomy extends TopLevelViewStateBase {\n    type: ViewType.TAXONOMY;\n    view: AsyncView<TaxonomyView, UIError>;\n};\n\nexport interface TopLevelViewStateOntology extends TopLevelViewStateBase {\n    type: ViewType.ONTOLOGY;\n    view: AsyncView<OntologyView, UIError>;\n}\n\nexport type TopLevelViewState = TopLevelViewStateTaxonomy | TopLevelViewStateOntology;\n\n\nexport type TopLevelView = AsyncView<TopLevelViewState, UIError>\n","\n\nimport { OntologyReference, OntologyNamespace } from './ontology';\nimport { TaxonomyReference, TaxonomyNamespace } from './taxonomy';\n\nexport type RelationEngineID = string;\n\nexport type RelationEngineTimestamp = number;\n\nexport enum RelationEngineCategory {\n    TAXONOMY,\n    ONTOLOGY\n}\n\nexport enum RelationEngineDataSource {\n    ENVO,\n    GO,\n    GTDB,\n    NCBI,\n    RDP\n}\n\nexport interface RelationEngineReferenceG<CategoryType extends RelationEngineCategory, DataSourceType extends RelationEngineDataSource> {\n    category: CategoryType;\n    dataSource: DataSourceType;\n    id: string;\n    timestamp: number\n}\n\n// export type OntologyReference =\n//     RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.GO> |\n//     RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.ENVO>;\n\n// export type TaxonomyReference =\n//     RelationEngineReferenceG<RelationEngineCategory.TAXONOMY, RelationEngineDataSource.NCBI> |\n//     RelationEngineReferenceG<RelationEngineCategory.TAXONOMY, RelationEngineDataSource.GTDB> |\n//     RelationEngineReferenceG<RelationEngineCategory.TAXONOMY, RelationEngineDataSource.RDP>;\n\nexport type RelationEngineReference = OntologyReference | TaxonomyReference;\n\nexport type RelationEngineNamespace = OntologyNamespace | TaxonomyNamespace;\n\n\n\n// export type RelationEngineReference =\n//     RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.GO> |\n//     RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.ENVO> |\n//     RelationEngineReferenceG<RelationEngineCategory.TAXONOMY, RelationEngineDataSource.NCBI> |\n//     RelationEngineReferenceG<RelationEngineCategory.TAXONOMY, RelationEngineDataSource.GTDB> |\n//     RelationEngineReferenceG<RelationEngineCategory.TAXONOMY, RelationEngineDataSource.RDP>\n\n","import { Action } from 'redux';\nimport { ThunkDispatch } from 'redux-thunk';\nimport { StoreState, RelationEngineID, NavigationSome, View } from '../store';\nimport { ViewType } from '../store/view';\nimport RelationEngineAPIClient from '../../lib/RelationEngineAPIClient';\nimport { stringToRelationEngineRef, stringToNamespace } from '../../types/transform';\nimport { RelationEngineCategory } from '../../types/core';\n\nexport enum AppActions {\n    NAVIGATE = 'kbase-ui-plugin-landing-pages/navigate',\n    NAVIGATE_START = 'kbase-ui-plugin-landing-pages/navigate/start',\n    NAVIGATE_SUCCESS = 'kbase-ui-plugin-landing-pages/navigate/success',\n    NAVIGATE_ERROR = 'kbase-ui-plugin-landing-pages/navigate/error'\n}\n\nexport interface Navigate extends Action<AppActions.NAVIGATE> {\n    type: AppActions.NAVIGATE;\n    relationEngineID: RelationEngineID;\n}\n\nexport interface NavigateStart extends Action<AppActions.NAVIGATE_START> {\n    type: AppActions.NAVIGATE_START;\n}\n\nexport interface NavigateSuccess extends Action<AppActions.NAVIGATE_SUCCESS> {\n    type: AppActions.NAVIGATE_SUCCESS;\n    navigation: NavigationSome;\n}\n\nexport interface NavigateError extends Action<AppActions.NAVIGATE_ERROR> {\n    type: AppActions.NAVIGATE_ERROR;\n    message: string;\n}\n\nexport function navigateStart(): NavigateStart {\n    return {\n        type: AppActions.NAVIGATE_START\n    };\n}\n\nexport function navigateError(message: string): NavigateError {\n    return {\n        type: AppActions.NAVIGATE_ERROR,\n        message\n    }\n}\n\nexport function navigateSuccess(\n    navigation: NavigationSome\n): NavigateSuccess {\n    return {\n        type: AppActions.NAVIGATE_SUCCESS,\n        navigation\n    };\n}\n\nexport function navigate(relationEngineID: RelationEngineID) {\n    return async (dispatch: ThunkDispatch<StoreState, void, Action>, getState: () => StoreState) => {\n        dispatch(navigateStart());\n\n        const {\n            auth: { userAuthorization },\n            app: {\n                config: {\n                    services: {\n                        RelationEngine: {url}\n                    }\n                }\n            }\n        } = getState();\n\n        if (!userAuthorization) {\n            return;\n        }\n\n        const reClient = new RelationEngineAPIClient({\n            url,\n            token: userAuthorization.token,\n            // TODO: move timeout into config\n            timeout: 10000\n        });\n\n        // TODO: for now we use the relation engine id string ns/id or ns/id/ts, but\n        // we should move to parsing this out before getting here...\n\n        try {\n            // TODO: combine getting the re ref with getting the namespace info,\n            // since the re ref needs the category.\n\n            const [ns,,] = relationEngineID.split('/');\n            const namespace = stringToNamespace(ns);\n\n            const dataSourceInfo = await reClient.dataSourceInfo(namespace);\n            console.log('datasource info?', dataSourceInfo);\n            const categoryString = dataSourceInfo.data_source.category;\n            const relationEngineRef = stringToRelationEngineRef(relationEngineID, categoryString);\n\n            // const [nodeInfo] = await reClient.getNodeInfo(relationEngineID);\n            switch (relationEngineRef.category) {\n                case RelationEngineCategory.TAXONOMY:\n                    // TODO: add source info here, or let the taxonomy landing page do\n                    // it by itself? I think it is better to do it after the first dispatch\n                    // here, because then the landing page can fold it into its type system,\n                    // rather than requiring the top level to do that. E.g. source->enum.\n                    dispatch(navigateSuccess({\n                        type: ViewType.TAXONOMY,\n                        ref: relationEngineRef\n                    }));\n                    // const x = {\n                    //     type: ViewType.TAXONOMY,\n                    //     ref: {\n                    //         collection: RelationEngineCollection.TAXONOMY,\n                    //         namespace: stringToTaxonomyNamespace(nodeInfo.namespace),\n                    //         id: nodeInfo.id,\n                    //         timestamp: nodeInfo.timestamp\n                    //     }\n                    // };\n                    break;\n                case RelationEngineCategory.ONTOLOGY:\n                    dispatch(navigateSuccess({\n                        type: ViewType.ONTOLOGY,\n                        ref: relationEngineRef\n                    }));\n                    break;\n            }\n        } catch (ex) {\n            console.error('ERROR', ex);\n            dispatch(navigateError(ex.message));\n        }\n\n    };\n}\n\nexport function view(view: View) {\n    return async (dispatch: ThunkDispatch<StoreState, void, Action>, getState: () => StoreState) => {\n\n\n        // determine which view should be invoked\n\n        // issue the store update accordingly\n\n        // the view should be invoked by the ... dispatcher?\n\n    };\n}\n","import axios from 'axios';\nimport { RelationEngineDataSource, RelationEngineNamespace } from '../types/core';\n\n// A collection is a top level division of the re data model\nexport type Collection = 'taxonomy' | 'ontology';\n\nexport interface GetNodeInfoResultBase {\n    collection: Collection;\n    // source: string;\n    created: number;\n    expired: number;\n    timestamp: number;\n}\n\nexport interface GetNodeInfoResultTaxon extends GetNodeInfoResultBase {\n    collection: 'taxonomy';\n    // source: TaxonSource;\n    namespace: string;\n    id: string;\n}\n\nexport interface GetNodeInfoResultOntology extends GetNodeInfoResultBase {\n    collection: 'ontology';\n    // source: OntologySource;\n    namespace: string;\n    id: string;\n}\n\nexport type GetNodeInfoResult = GetNodeInfoResultTaxon | GetNodeInfoResultOntology;\n\n// export interface GetNodeInfoResult<T, S> {\n//     type: NodeType;\n//     created: number;\n//     source: TaxonSource | OntologySource;\n//     version: string;\n// }\n\nexport type DataSourceCategory = 'taxonomy' | 'ontology';\n\nexport interface DataSourcesResult {\n    data_sources: Array<RelationEngineDataSource>\n}\n\nexport interface DataSourceInfoResult {\n    data_source: {\n        category: DataSourceCategory;\n        name: RelationEngineDataSource;\n        data_url: string;\n        home_url: string;\n        logo_url: string;\n        title: string;\n    }\n}\n\nexport interface RestClientParams {\n    url: string;\n    timeout: number;\n    token: string;\n}\n\nexport class RestClient {\n    params: RestClientParams;\n    constructor(params: RestClientParams) {\n        this.params = params;\n    }\n\n    async get<ResultType>(path: Array<string>): Promise<ResultType> {\n        const url = this.params.url + '/' + path.join('/');\n        const result = await axios.get(url, {\n            headers: {\n                Accept: 'application/json'\n            }\n        })\n        // TODO: handle errors!\n\n\n        return (result.data as unknown) as ResultType;\n    }\n}\n\n// function idToRef(relationEngineID: RelationEngineID): RelationEngineReference {\n\n// }\n\nexport default class RelationEngineAPIClient extends RestClient {\n    async dataSources(): Promise<DataSourcesResult> {\n        return this.get<DataSourcesResult>(['data_sources']);\n    }\n\n    async dataSourceInfo(dataSource: RelationEngineNamespace): Promise<DataSourceInfoResult> {\n        const path = [\n            'api',\n            'v1',\n            'data_sources',\n            dataSource\n        ];\n        console.log('PATH', path);\n        return this.get<DataSourceInfoResult>(path);\n    }\n\n    // async getNodeInfo(relationEngineID: RelationEngineID): Promise<[GetNodeInfoResult]> {\n    //     const classRe = /^(.*?)\\/(.*)$/;\n    //     const taxonomyRe = /^([^/]+)\\/([^/]+)(?:\\/([^/]+))?$/;\n    //     const ontologyRe = /^([^/]+)\\/([^/]+)(?:\\/([^/]+))?$/;\n    //     return new Promise<[GetNodeInfoResult]>((resolve, reject) => {\n    //         let m = classRe.exec(relationEngineID);\n    //         if (!m) {\n    //             reject(new Error('Invalid relation engine ID ' + relationEngineID));\n    //             return;\n    //         }\n    //         const [, collection, rest] = m;\n    //         // const [collection] = relationEngineID.split('/');\n    //         switch (collection) {\n    //             case 'taxonomy': (() => {\n    //                 m = taxonomyRe.exec(rest);\n    //                 if (!m) {\n    //                     reject(new Error('Taxonomy ref is '));\n    //                     return;\n    //                 }\n    //                 if (m.length !== 4) {\n    //                     reject(new Error('Invalid relation engine id \"' + relationEngineID + '\"'));\n    //                 }\n    //                 const [, namespace, id, timestampString] = m;\n    //                 let timestamp: number;\n    //                 if (!timestampString) {\n    //                     timestamp = Date.now();\n    //                 } else {\n    //                     timestamp = parseInt(timestampString, 10);\n    //                 }\n\n    //                 switch (namespace) {\n    //                     case 'ncbi_taxonomy':\n    //                         resolve([\n    //                             {\n    //                                 collection: 'taxonomy',\n    //                                 namespace: namespace,\n    //                                 id: id,\n    //                                 timestamp,\n    //                                 created: Date.now(),\n    //                                 expired: new Date(2055, 5, 5).getTime()\n    //                             }\n    //                         ]);\n    //                         return;\n    //                     default:\n    //                         reject(new Error('Unrecognized taxonomy namespace \"' + namespace + '\"'));\n    //                         return;\n    //                 }\n    //             })();\n    //                 break;\n    //             case 'ontology':\n    //                 m = ontologyRe.exec(rest);\n    //                 if (!m) {\n    //                     reject(new Error('Taxonomy ref is '));\n    //                     return;\n    //                 }\n    //                 const [, namespace, id, timestampString] = m;\n    //                 let timestamp: number;\n    //                 if (timestampString) {\n    //                     timestamp = parseInt(timestampString);\n    //                 } else {\n    //                     timestamp = Date.now();\n    //                 }\n    //                 switch (namespace) {\n    //                     case 'go':\n    //                         resolve([\n    //                             {\n    //                                 collection: 'ontology',\n    //                                 namespace,\n    //                                 id,\n    //                                 timestamp,\n    //                                 created: Date.now(),\n    //                                 expired: new Date(2055, 5, 5).getTime()\n    //                             }\n    //                         ]);\n    //                         return;\n    //                     default:\n    //                         reject(new Error('Ontology namespace not found \"' + namespace + '\"'));\n    //                         return;\n    //                 }\n    //             default:\n    //                 reject(new Error(`Collection ${collection} does not resolve to a type`));\n    //         }\n    //     });\n    // }\n}\n","\nimport * as core from './core';\n\nexport function relationEngineNamespaceToDataSource(s: core.RelationEngineNamespace): core.RelationEngineDataSource {\n    switch (s) {\n        case 'go_ontology':\n            return core.RelationEngineDataSource.GO;\n        case 'envo_ontology':\n            return core.RelationEngineDataSource.ENVO;\n        case 'ncbi_taxonomy':\n            return core.RelationEngineDataSource.NCBI;\n        case 'gtdb_taxonomy':\n            return core.RelationEngineDataSource.GTDB;\n        case 'rdp_taxonomy':\n            return core.RelationEngineDataSource.RDP;\n        // default:\n        //     throw new Error('Unrecognized data source: ' + s);\n    }\n}\n\n// export function dataSourceToNamespace(dataSource: core.RelationEngineDataSource): core.RelationEngineNamespace {\n//     switch (dataSource) {\n//         case core.RelationEngineDataSource.GO:\n//             return 'go_ontology';\n//         case core.RelationEngineDataSource.ENVO:\n//             return 'envo_ontology';\n//         case core.RelationEngineDataSource.NCBI:\n//                 return 'go_ontology';\n//                 case core.RelationEngineDataSource.GO:\n//                         return 'go_ontology';\n//                         case core.RelationEngineDataSource.GO:\n//                                 return 'go_ontology';\n//     }\n// }\n\nexport function relationEngineCategoryToString(category: core.RelationEngineCategory): string {\n    switch (category) {\n        case core.RelationEngineCategory.TAXONOMY:\n            return 'taxonomy';\n        case core.RelationEngineCategory.ONTOLOGY:\n            return 'ontology';\n    }\n}\n\nexport function stringToRelationEngineCategory(categoryString: string) {\n    switch (categoryString) {\n        case 'taxonomy':\n            return core.RelationEngineCategory.TAXONOMY;\n        case 'ontology':\n            return core.RelationEngineCategory.ONTOLOGY;\n        default:\n            throw new Error('Unrecognized relation engine category name \"' + categoryString + '\"');\n    }\n}\n\nexport function stringToNamespace(s: string): core.RelationEngineNamespace {\n    const namespaces = [\n        'go_ontology',\n        'envo_ontology',\n        'gtdb_taxonomy',\n        'ncbi_taxonomy',\n        'rdp_taxonomy'\n    ];\n    // TODO: i don't like the _as_ :(\n    // A verbose alternative is a switch\n    if (namespaces.includes(s)) {\n        return s as core.RelationEngineNamespace;\n    }\n    throw new Error('Not a valid namespace: ' + s);\n}\n\nexport function stringToRelationEngineRef(relationEngineID: core.RelationEngineID, categoryString: string): core.RelationEngineReference {\n    const [namespaceString, id, timestampString] = relationEngineID.split('/');\n    const dataSource = relationEngineNamespaceToDataSource(stringToNamespace(namespaceString));\n    const category = stringToRelationEngineCategory(categoryString);\n\n    let timestamp: number;\n    if (typeof timestampString === 'undefined') {\n        timestamp = Date.now();\n    } else {\n        timestamp = parseInt(timestampString, 10);\n    }\n\n    switch (category) {\n        case core.RelationEngineCategory.ONTOLOGY:\n            switch (dataSource) {\n                case core.RelationEngineDataSource.GO:\n                    return {category, dataSource, id, timestamp}\n                case core.RelationEngineDataSource.ENVO:\n                    return {category, dataSource, id, timestamp}\n                default:\n                    throw new Error('Invalid data source for ontology');\n            }\n        case core.RelationEngineCategory.TAXONOMY:\n            switch (dataSource) {\n                case core.RelationEngineDataSource.NCBI:\n                    return {category, dataSource, id, timestamp}\n                case core.RelationEngineDataSource.GTDB:\n                    return {category, dataSource, id, timestamp}\n                case core.RelationEngineDataSource.RDP:\n                    return {category, dataSource, id, timestamp}\n                default:\n                    throw new Error('Invalid data source for taxonomy');\n            }\n    }\n}\n\nexport function relationEngineReferenceToNamespace(ref: core.RelationEngineReference): core.RelationEngineNamespace {\n    switch (ref.category) {\n        case core.RelationEngineCategory.ONTOLOGY:\n            switch (ref.dataSource) {\n                case core.RelationEngineDataSource.GO:\n                    return 'go_ontology';\n                case core.RelationEngineDataSource.ENVO:\n                    return 'envo_ontology';\n            }\n            break;\n        case core.RelationEngineCategory.TAXONOMY:\n            switch (ref.dataSource) {\n                case core.RelationEngineDataSource.NCBI:\n                    return 'ncbi_taxonomy';\n                case core.RelationEngineDataSource.GTDB:\n                    return 'gtdb_taxonomy';\n                case core.RelationEngineDataSource.RDP:\n                    return 'rdp_taxonomy';\n            }\n    }\n}","import { Action, Reducer } from 'redux';\nimport { baseReducer, BaseStoreState } from '@kbase/ui-components';\nimport { StoreState } from '../store';\nimport { AppActions, NavigateSuccess } from '../actions';\n\nfunction navigateSuccess(state: StoreState, action: NavigateSuccess): StoreState {\n    return {\n        ...state,\n        // view: {\n        //     status: ViewStatus.LOADED,\n        //     relationEngineID: action.relationEngineID,\n        //     relationEngineNodeType: action.relationEngineNodeType,\n        //     viewType: action.viewType,\n        //     currentView: action.view\n        // }\n        navigation: action.navigation,\n        trigger: Date.now()\n    };\n}\n\n// function navigateStart(state: StoreState, action: NavigateStart): StoreState {\n//     return {\n//         ...state,\n//         view: {\n//             status: ViewStatus.LOADING\n//         }\n//     };\n// }\n\nconst reducer: Reducer<StoreState | undefined, Action> = (state: StoreState | undefined, action: Action) => {\n    const baseState = baseReducer(state as BaseStoreState, action);\n    if (baseState) {\n        return baseState as StoreState;\n    }\n    if (!state) {\n        return state;\n    }\n    switch (action.type) {\n        // case AppActions.NAVIGATE_START:\n        //     return navigateStart(state, action as NavigateStart);\n        case AppActions.NAVIGATE_SUCCESS:\n            return navigateSuccess(state, action as NavigateSuccess);\n    }\n    return state;\n};\n\nexport default reducer;\n","import { BaseStoreState, makeBaseStoreState } from '@kbase/ui-components';\nimport { createStore, compose, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport reducer from '../reducers';\n\n// import { TaxonomyStoreState } from '../../landingPages/taxonomy/redux/store';\nimport { TaxonomyReference } from '../../types/taxonomy';\nimport { OntologyReference } from '../../types/ontology';\nimport { AsyncViewStatus, TopLevelView, ViewType, ViewBase } from './view';\nimport { TaxonomyView } from './taxonomy';\nimport { OntologyView } from './ontology';\n\n\nexport type RelationEngineID = string;\nexport enum RelationEngineNodeType {\n    TAXON,\n    ONTOLOGY_TERM\n}\n\nexport enum ViewStatus {\n    NONE,\n    LOADING,\n    LOADED,\n    ERROR\n}\n\n// export interface RelationEngineViewBase {\n//     status: ViewStatus;\n// }\n\n// export interface RelationEngineViewNone {\n//     status: ViewStatus.NONE;\n// }\n\n// export interface RelationEngineViewLoading {\n//     status: ViewStatus.LOADING;\n// }\n\n// export interface RelationEngineViewLoaded {\n//     status: ViewStatus.LOADED;\n//     relationEngineID: RelationEngineID;\n//     relationEngineNodeType: RelationEngineNodeType;\n//     viewType: ViewType;\n//     currentView: LandingPageView;\n// }\n\n// export interface RelationEngineViewError {\n//     status: ViewStatus.ERROR;\n//     message: string;\n// }\n\n// export type RelationEngineView =\n//     | RelationEngineViewNone\n//     | RelationEngineViewLoading\n//     | RelationEngineViewLoaded\n//     | RelationEngineViewError;\n\nexport interface LandingPageStoreState { }\n\n\n\n\nexport interface NavigationBase {\n    type: ViewType;\n    relationEngineID: RelationEngineID;\n}\n\nexport interface NavigationNone {\n    type: ViewType.NONE;\n}\n\nexport interface NavigationTaxonomy {\n    type: ViewType.TAXONOMY;\n    ref: TaxonomyReference\n}\n\nexport interface NavigationOntology {\n    type: ViewType.ONTOLOGY;\n    ref: OntologyReference\n}\n\nexport type NavigationSome = NavigationTaxonomy | NavigationOntology;\nexport type Navigation = NavigationNone | NavigationSome;\n\n// export interface ViewState<T, S> {\n//     type: T;\n//     state: S;\n// }\n\n// export type LandingPageView = TaxonomyView;\n\n// OKAY, back to REDUX\n\n// export interface TaxonomyView {\n\n// }\n\n// export interface OntologyView {\n\n// }\n\n\n\nexport type View = ViewBase<TaxonomyView> | ViewBase<OntologyView> | null;\n\n\n// STORE STATE type definition\nexport interface StoreState extends BaseStoreState {\n    navigation: Navigation;\n    trigger: number;\n    view: TopLevelView;\n}\n\n// Store Construction\nexport function makeInitialStoreState(): StoreState {\n    const baseStoreState = makeBaseStoreState();\n    return {\n        ...baseStoreState,\n        // viewer: null,\n        navigation: {\n            type: ViewType.NONE\n        },\n        trigger: 0,\n        view: {\n            status: AsyncViewStatus.NONE\n        }\n    };\n}\n\nexport function createReduxStore() {\n    return createStore(reducer, makeInitialStoreState(), compose(applyMiddleware(thunk)));\n}\n","import { UIError } from '../types/error';\n\nexport interface DBProps<T> {\n    onUpdate: () => void;\n    initialData: T;\n}\n\nexport interface TheDB<T> {\n    data: T;\n}\n\nexport enum DBStatus {\n    NONE,\n    LOADING,\n    LOADED,\n    RELOADING,\n    ERROR\n}\n\nexport interface DBStateNone {\n    status: DBStatus.NONE;\n}\n\nexport interface DBStateLoading {\n    status: DBStatus.LOADING;\n}\n\nexport interface DBStateReLoading {\n    status: DBStatus.RELOADING;\n}\n\nexport interface DBStateLoaded {\n    status: DBStatus.LOADED;\n}\n\nexport interface DBStateError {\n    status: DBStatus.ERROR;\n    error: UIError;\n}\n\nexport default class DB<T> {\n    db: TheDB<T>;\n    stopped: boolean;\n    onUpdate: () => void;\n    constructor(props: DBProps<T>) {\n        this.onUpdate = props.onUpdate;\n        this.db = {\n            data: props.initialData\n        };\n        this.stopped = false;\n    }\n\n    forceComponentUpdate() {\n        if (this.stopped) {\n            return;\n        }\n        this.onUpdate();\n    }\n\n    set(updateFun: (state: T) => T) {\n        this.db.data = updateFun(this.db.data);\n        this.forceComponentUpdate();\n    }\n\n    get(): T {\n        return this.db.data;\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n}\n","import { TaxonomyReference, Taxon, NCBITaxon } from '../../../types/taxonomy';\nimport TaxonAPIClient from './TaxonAPIClient';\nimport { relationEngineReferenceToNamespace } from '../../../types/transform';\nimport { RelationEngineCategory, RelationEngineDataSource, } from '../../../types/core';\n\n// const INITIAL_BATCH_SIZE = 100;\n// const BATCH_SIZE = 1000;\n// const TOTAL_LIMIT = 10000;\n// const PARALLELISM = 2;\n\nexport interface GetChildrenOptions {\n    offset: number;\n    limit: number;\n    searchTerm: string;\n}\n\nexport interface WorkspaceObjectType {\n    module: string;\n    name: string;\n    majorVersion: number;\n    minorVersion: number;\n}\n\nexport enum WorkspaceType {\n    UNKNOWN,\n    NARRATIVE,\n    REFDATA\n}\n\nexport interface LinkedObject {\n    linkedAt: number;\n    workspaceID: number;\n    objectID: number;\n    version: number;\n    objectName: string;\n    workspaceUpdatedAt: number;\n    createdAt: number;\n    type: WorkspaceObjectType;\n    workspaceType: WorkspaceType;\n    title: string;\n}\n\nexport interface GetLinkedObjectsOptions {\n    offset: number;\n    limit: number;\n}\n\nexport interface GetLinkedObjectsResult {\n    linkedObjects: Array<LinkedObject>;\n    totalCount: number;\n}\n\nexport class TaxonomyModel {\n    taxonomyClient: TaxonAPIClient;\n    constructor({ token, url }: { token: string; url: string }) {\n        this.taxonomyClient = new TaxonAPIClient({ token, url });\n    }\n\n    async getLineage(taxonRef: TaxonomyReference): Promise<Array<Taxon>> {\n        const {\n            id, timestamp\n        } = taxonRef;\n        const result = await this.taxonomyClient.getLineage({\n            ns: relationEngineReferenceToNamespace(taxonRef),\n            id,\n            ts: timestamp\n        });\n        // TODO: should be conditional based on the source of the taxonomy??\n        const taxons: Array<NCBITaxon> = result.results.map((taxonResult) => {\n            let isBiological: boolean;\n            if (taxonResult.scientific_name === 'root' || taxonResult.scientific_name === 'cellular organisms') {\n                isBiological = false;\n            } else {\n                isBiological = true;\n            }\n            return {\n                ref: {\n                    category: RelationEngineCategory.TAXONOMY,\n                    dataSource: RelationEngineDataSource.NCBI,\n                    id: taxonResult.id,\n                    timestamp: result.ts\n                },\n                name: taxonResult.scientific_name,\n                rank: taxonResult.rank,\n                ncbiID: taxonResult.NCBI_taxon_id,\n                geneticCode: parseInt(taxonResult.gencode),\n                aliases: taxonResult.aliases.map(({ name, category }) => {\n                    return {\n                        name,\n                        category\n                    };\n                }),\n                isBiological\n            };\n        });\n        return taxons;\n    }\n\n    async getChildren(taxonRef: TaxonomyReference, options: GetChildrenOptions): Promise<[Array<Taxon>, number]> {\n        const {\n            id, timestamp\n        } = taxonRef;\n\n        const result = await this.taxonomyClient.getChildren({\n            ns: relationEngineReferenceToNamespace(taxonRef),\n            id,\n            ts: timestamp,\n            offset: options.offset,\n            limit: options.limit,\n            searchTerm: options.searchTerm\n        });\n\n        const taxa: Array<NCBITaxon> = result.results.map((taxonResult) => {\n            let isBiological: boolean;\n            if (taxonResult.scientific_name === 'root' || taxonResult.scientific_name === 'cellular organisms') {\n                isBiological = false;\n            } else {\n                isBiological = true;\n            }\n            return {\n                ref: {\n                    category: RelationEngineCategory.TAXONOMY,\n                    dataSource: RelationEngineDataSource.NCBI,\n                    id: taxonResult.id,\n                    timestamp: result.ts\n                },\n                name: taxonResult.scientific_name,\n                rank: taxonResult.rank,\n                ncbiID: taxonResult.NCBI_taxon_id,\n                geneticCode: parseInt(taxonResult.gencode),\n                aliases: taxonResult.aliases.map(({ name, category }) => {\n                    return {\n                        name,\n                        category\n                    };\n                }),\n                isBiological\n            };\n        });\n        return [taxa, result.total_count];\n    }\n\n    // async getChildrenx(taxonID: TaxonID, options: GetChildrenOptions): Promise<[Array<Taxon>, number, number]> {\n    //     // Loop over results until done!\n    //     // Get the first batch. In the majority of cases, this will be it.\n\n    //     const getBatch = async (batch: number, batchSize: number): Promise<[Array<Taxon>, number]> => {\n    //         const offset = batch * batchSize;\n    //         const result = await this.taxonomyClient.getChildren({\n    //             taxonID,\n    //             offset,\n    //             limit: batchSize\n    //         });\n\n    //         const taxa = result.results.map((taxonResult) => {\n    //             let isBiological: boolean;\n    //             if (taxonResult.scientific_name === 'root' || taxonResult.scientific_name === 'cellular organisms') {\n    //                 isBiological = false;\n    //             } else {\n    //                 isBiological = true;\n    //             }\n    //             return {\n    //                 type: TaxonomySource.NCBI,\n    //                 id: taxonResult._id,\n    //                 name: taxonResult.scientific_name,\n    //                 rank: taxonResult.rank,\n    //                 ncbiID: taxonResult.NCBI_taxon_id,\n    //                 geneticCode: parseInt(taxonResult.gencode),\n    //                 aliases: taxonResult.aliases.map(({ name, category }) => {\n    //                     return {\n    //                         name,\n    //                         category\n    //                     };\n    //                 }),\n    //                 isBiological\n    //             };\n    //         });\n    //         return [taxa, result.total_count];\n    //     };\n\n    //     const [taxa, totalCount] = await getBatch(0, INITIAL_BATCH_SIZE);\n\n    //     if (totalCount <= taxa.length) {\n    //         return [taxa, totalCount, totalCount];\n    //     }\n\n    //     // Here we cap the total results requested to TOTAL_LIMIT\n    //     let totalLimit = Math.min(totalCount, TOTAL_LIMIT);\n\n    //     // How many batches do we need to fetch?\n    //     const totalBatchCount = Math.ceil((totalLimit - INITIAL_BATCH_SIZE) / BATCH_SIZE);\n\n    //     // In order to avoid overwhelming the service, we need to limit the\n    //     // # of concurrent requests.\n    //     const iterations = Math.ceil(totalBatchCount / PARALLELISM);\n\n    //     console.log('BATCHES', totalBatchCount, iterations);\n\n    //     let result = taxa;\n\n    //     console.log('taxa', taxa);\n\n    //     for (let iter = 0; iter < iterations; iter += 1) {\n    //         const pendingBatches: Array<Promise<[Array<Taxon>, number]>> = [];\n\n    //         const batchCount = Math.min(PARALLELISM, totalBatchCount - iter * PARALLELISM);\n\n    //         console.log(`iter ${iter}`);\n\n    //         for (let batch = 0; batch < batchCount; batch += 1) {\n    //             const offset = iter * PARALLELISM + batch;\n    //             const batchSize = Math.min(BATCH_SIZE, totalLimit - offset * BATCH_SIZE);\n    //             console.log('BATCH SIZE', batchSize, iter, batch, totalLimit - offset * BATCH_SIZE);\n    //             pendingBatches.push(getBatch(offset, batchSize));\n    //             // const [nextResult] = await getBatch(i);\n    //             // console.log('adding another batch', nextResult);\n    //             // result = result.concat(nextResult);\n    //         }\n\n    //         const batches = await Promise.all(pendingBatches);\n\n    //         result = result.concat.apply(\n    //             result,\n    //             batches.map(([taxa, count]) => {\n    //                 return taxa;\n    //             })\n    //         );\n    //     }\n\n    //     return [result, totalCount, totalLimit];\n    // }\n\n    async getTaxon(taxonRef: TaxonomyReference): Promise<Taxon> {\n        const {\n            id, timestamp\n        } = taxonRef;\n\n        const result = await this.taxonomyClient.getTaxon({\n            ns: relationEngineReferenceToNamespace(taxonRef),\n            id,\n            ts: timestamp\n        });\n\n        // if (!result.count) {\n        //     throw new Error(`Taxon not found`);\n        // }\n        const taxonResult = result.results[0];\n        let isBiological: boolean;\n        if (taxonResult.scientific_name === 'root' || taxonResult.scientific_name === 'cellular organisms') {\n            isBiological = false;\n        } else {\n            isBiological = true;\n        }\n\n        // TODO: here and above, we need to determine the namespace enum value by \n        // comparing the string coming in...\n        const taxon: Taxon = {\n            ref: {\n                category: RelationEngineCategory.TAXONOMY,\n                dataSource: RelationEngineDataSource.NCBI,\n                id: taxonResult.id,\n                timestamp: result.ts\n            },\n            name: taxonResult.scientific_name,\n            rank: taxonResult.rank,\n            ncbiID: taxonResult.NCBI_taxon_id,\n            geneticCode: parseInt(taxonResult.gencode),\n            aliases: taxonResult.aliases.map(({ name, category }) => {\n                return {\n                    name,\n                    category\n                };\n            }),\n            isBiological\n        };\n        return taxon;\n    }\n\n    async getLinkedObjects(taxonRef: TaxonomyReference, options: GetLinkedObjectsOptions): Promise<GetLinkedObjectsResult> {\n        const params = {\n            taxon_ns: relationEngineReferenceToNamespace(taxonRef),\n            taxon_id: taxonRef.id,\n            ts: taxonRef.timestamp,\n            offset: options.offset,\n            limit: options.limit\n        };\n        const result = await this.taxonomyClient.getAssociatedWorkspaceObjects(params);\n\n        const linkedObjects = result.results.map((result) => {\n            let workspaceType: WorkspaceType;\n            let title: string;\n            if (result.ws_obj.workspace.narr_name) {\n                workspaceType = WorkspaceType.NARRATIVE;\n                title = result.ws_obj.workspace.narr_name;\n            } else if (result.ws_obj.workspace.refdata_source) {\n                workspaceType = WorkspaceType.REFDATA;\n                title = result.ws_obj.workspace.refdata_source + ' Reference Data';\n            } else {\n                workspaceType = WorkspaceType.UNKNOWN;\n                title = 'Unknown Workspace Type';\n            }\n            return {\n                linkedAt: result.edge.updated_at,\n                objectID: result.ws_obj.object_id,\n                workspaceID: result.ws_obj.workspace_id,\n                version: result.ws_obj.version,\n                objectName: result.ws_obj.name,\n                createdAt: result.ws_obj.epoch,\n                workspaceUpdatedAt: result.ws_obj.updated_at,\n                type: {\n                    module: result.ws_obj.type.module_name,\n                    name: result.ws_obj.type.type_name,\n                    majorVersion: result.ws_obj.type.maj_ver,\n                    minorVersion: result.ws_obj.type.min_ver\n                },\n                workspaceType,\n                title\n            };\n        });\n        return {\n            linkedObjects,\n            totalCount: result.total_count\n        };\n    }\n}\n","import { DynamicServiceClient, DynamicServiceClientParams } from '@kbase/ui-lib';\n\ninterface TaxonomyAPIParams extends DynamicServiceClientParams { }\n\ntype TaxonID = string;\n\ninterface GetAncestorsParams {\n    id: TaxonID;\n}\n\ninterface GetDescendentsParams {\n    id: TaxonID;\n}\n\n// interface GetTaxonResultSuccess {\n//     count: true;\n//     taxon: Taxon;\n// }\n\n// interface GetTaxonResultNotFound {\n//     found: false;\n// }\n\n// type GetTaxonResult = GetTaxonResultSuccess | GetTaxonResultNotFound;\n\ninterface TaxonAlias {\n    canonical: Array<string>;\n    category: string;\n    name: string;\n}\n\ninterface TaxonResult {\n    NCBI_taxon_id: number;\n    _id: string;\n    _key: string;\n    _rev: string;\n    id: string;\n    ns: string;\n    ts: number;\n    aliases: Array<TaxonAlias>;\n    canonical_scientific_name: Array<string>;\n    gencode: string;\n    rank: string;\n    scientific_name: string;\n}\n\nexport interface GetTaxonParams {\n    ns: string;\n    id: TaxonID;\n    ts: number\n}\n\ninterface GetTaxonResult {\n    count: number;\n    cursor_id: number | null;\n    has_more: false;\n    stats: {\n        executionTime: number;\n        filtered: number;\n        httpRequests: number;\n        scannedFull: number;\n        scannedIndex: number;\n        writesExecuted: number;\n        writesIgnored: number;\n    };\n    results: Array<TaxonResult>;\n    ts: number;\n}\n\ninterface GetLineageResult {\n    stats: {\n        executionTime: number;\n        filtered: number;\n        httpRequests: number;\n        scannedFull: number;\n        scannedIndex: number;\n        writesExecuted: number;\n        writesIgnored: number;\n    };\n    results: Array<TaxonResult>;\n    ts: number;\n}\n\ninterface GetChildrenResult {\n    stats: {\n        executionTime: number;\n        filtered: number;\n        httpRequests: number;\n        scannedFull: number;\n        scannedIndex: number;\n        writesExecuted: number;\n        writesIgnored: number;\n    };\n    results: Array<TaxonResult>;\n    total_count: number;\n    ts: number;\n}\nexport interface Stats {\n    executionTime: number;\n    filtered: number;\n    httpRequests: number;\n    scannedFull: number;\n    scannedIndex: number;\n    writesExecuted: number;\n    writesIgnored: number;\n}\nexport interface GetAssociatedWorkspaceObjectsResultResult {\n    edge: {\n        _id: string;\n        assigned_by: string;\n        updated_at: number;\n    };\n    ws_obj: {\n        _id: string;\n        deleted: boolean;\n        epoch: number;\n        hash: string;\n        is_public: boolean;\n        name: string;\n        object_id: number;\n        size: number;\n        updated_at: number;\n        version: number;\n        workspace_id: number;\n        type: {\n            module_name: string;\n            type_name: string;\n            maj_ver: number;\n            min_ver: number;\n        },\n        workspace: {\n            narr_name: string | null;\n            refdata_source: string | null;\n        }\n    };\n}\n\nexport interface GetAssociatedWorkspaceObjectsResult {\n    results: Array<GetAssociatedWorkspaceObjectsResultResult>;\n    total_count: number;\n    stats: Stats;\n    ts: number;\n}\n\nexport interface GetLineageParams {\n    ns: string;\n    id: TaxonID;\n    ts: number;\n}\n\nexport interface GetChildrenParams {\n    ns: string;\n    id: TaxonID;\n    ts: number;\n    offset: number;\n    limit: number;\n    search_text: string;\n}\n\nexport interface GetAssociatedWorkspaceObjectsParams {\n    taxon_ns: string;\n    taxon_id: TaxonID;\n    ts: number;\n    limit: number;\n    offset: number;\n}\n\nexport default class TaxonomyAPIClient extends DynamicServiceClient {\n    static module: string = 'taxonomy_re_api';\n\n    async getLineage({ ns, id, ts }: { ns: string, id: TaxonID, ts: number }): Promise<GetLineageResult> {\n        const params: GetLineageParams = {\n            ns, id, ts\n        };\n        const [result] = await this.callFunc<[GetLineageParams], [GetLineageResult]>('get_lineage', [\n            params\n        ]);\n        return result;\n    }\n\n    async getChildren({\n        ns,\n        id,\n        ts,\n        offset,\n        limit,\n        searchTerm\n    }: {\n        ns: string,\n        id: TaxonID,\n        ts: number,\n        offset: number,\n        limit: number,\n        searchTerm: string\n    }): Promise<GetChildrenResult> {\n        const [result] = await this.callFunc<[GetChildrenParams], [GetChildrenResult]>('get_children', [\n            {\n                ns, id, ts,\n                offset,\n                limit,\n                search_text: searchTerm\n            }\n        ]);\n        return result;\n    }\n\n    async getTaxon({ ns, id, ts }: { ns: string, id: TaxonID, ts: number }): Promise<GetTaxonResult> {\n        const params: GetTaxonParams = {\n            ns, id, ts\n        }\n        const [result] = await this.callFunc<[GetTaxonParams], [GetTaxonResult]>('get_taxon', [\n            params\n        ]);\n        return result;\n    }\n\n    async getAssociatedWorkspaceObjects({\n        taxon_ns,\n        taxon_id,\n        ts,\n        offset,\n        limit\n    }: {\n        taxon_ns: string,\n        taxon_id: TaxonID,\n        ts: number,\n        offset: number,\n        limit: number\n    }): Promise<GetAssociatedWorkspaceObjectsResult> {\n        const params: GetAssociatedWorkspaceObjectsParams = {\n            taxon_ns, taxon_id, ts, limit, offset\n        }\n        const [result] = await this.callFunc<[GetAssociatedWorkspaceObjectsParams], [GetAssociatedWorkspaceObjectsResult]>('get_associated_ws_objects', [\n            params\n        ]);\n        console.log('associated', result);\n        return result;\n    }\n}\n","import DB, { DBProps, DBStatus, DBStateNone, DBStateLoading, DBStateLoaded, DBStateError } from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport { Taxon, TaxonomyReference } from '../../../types/taxonomy';\nimport { TaxonomyModel } from '../lib/model';\n\nexport type TaxonDBStateNone = DBStateNone;\nexport type TaxonDBStateLoading = DBStateLoading;\nexport type TaxonDBStateError = DBStateError;\n\nexport interface TaxonDBStateLoaded extends DBStateLoaded {\n    targetTaxon: Taxon;\n    selectedTaxon: Taxon;\n}\n\nexport type TaxonDBState = TaxonDBStateNone | TaxonDBStateLoading | TaxonDBStateLoaded | TaxonDBStateError;\n\nexport interface TaxonDBProps extends DBProps<TaxonDBState> {\n    token: string;\n    config: AppConfig;\n}\n\n// TODO: make props part of generic\nexport default class TaxonDB extends DB<TaxonDBState> {\n    props: TaxonDBProps;\n    constructor(props: TaxonDBProps) {\n        super(props);\n        this.props = props;\n    }\n    async getTargetTaxon(taxonRef: TaxonomyReference) {\n        try {\n            this.set((state: TaxonDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADING\n                };\n            });\n\n            const client = new TaxonomyModel({\n                token: this.props.token,\n                url: this.props.config.services.ServiceWizard.url\n            });\n\n            const taxon = await client.getTaxon(taxonRef);\n            this.set((state: TaxonDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    targetTaxon: taxon,\n                    selectedTaxon: taxon\n                };\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: TaxonDBState) => {\n                return {\n                    status: DBStatus.ERROR,\n                    error: {\n                        code: 'not-found',\n                        source: 'TaxonDB.getTargetTaxon',\n                        message: ex.message,\n                    }\n                };\n            });\n        }\n    }\n\n    async getSelectedTaxon(taxonRef: TaxonomyReference) {\n        try {\n            // this.set((state: TaxonDBState) => {\n            //     return {\n            //         ...state,\n            //         status: DBStatus.LOADING\n            //     };\n            // });\n\n            const client = new TaxonomyModel({\n                token: this.props.token,\n                url: this.props.config.services.ServiceWizard.url\n            });\n\n            const taxon = await client.getTaxon(taxonRef);\n            this.set((state: TaxonDBState) => {\n                return {\n                    ...state,\n                    selectedTaxon: taxon\n                };\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: TaxonDBState) => {\n                return {\n                    status: DBStatus.ERROR,\n                    error: {\n                        code: 'not-found',\n                        source: 'TaxonDB.getSelectedTaxon',\n                        message: ex.message,\n                    }\n                };\n            });\n        }\n    }\n}\n","import React from 'react';\nimport './SourceInfo.css';\n\nexport interface SourceInfoProps {}\n\ninterface SourceInfoState {}\n\nexport class SourceInfo extends React.Component<SourceInfoProps, SourceInfoState> {\n    render() {\n        return (\n            <div className=\"Row\">\n                <div className=\"Col-auto\">\n                    <img src=\"images/ncbi-logo.jpg\" style={{ height: '64px' }} alt=\"NCBI Logo\" />\n                </div>\n                <div className=\"Col\">\n                    <div className=\"InfoTable\">\n                        <div className=\"InfoTable-row\">\n                            <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                                Source\n                            </div>\n                            <div className=\"InfoTable-dataCol\">\n                                <a\n                                    href=\"https://www.ncbi.nlm.nih.gov/guide/taxonomy/\"\n                                    target=\"_blank\"\n                                    rel=\"noopener noreferrer\"\n                                >\n                                    NCBI\n                                </a>\n                            </div>\n                        </div>\n                        <div className=\"InfoTable-row\">\n                            <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                                Version\n                            </div>\n                            <div className=\"InfoTable-dataCol\">SOME VERSION</div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { Taxon, TaxonomyReference } from '../../types/taxonomy';\nimport { Tooltip, Icon } from 'antd';\nimport './TaxonItem.css';\nimport { relationEngineReferenceToNamespace } from '../../types/transform';\n\nexport interface Props {\n    taxon: Taxon;\n    isActive: boolean;\n    selectTaxonRef: (ref: TaxonomyReference) => void;\n    navigateToTaxonRef: (ref: TaxonomyReference) => void;\n}\n\ninterface State {\n    hovering: boolean;\n}\n\nexport default class TaxonItem extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            hovering: false\n        };\n    }\n    clickTaxon() {\n        this.props.selectTaxonRef(this.props.taxon.ref);\n    }\n    clickNavigateToTaxon() {\n        // const fixedID = this.props.taxon.id.replace('/', ':');\n        const hash = [\n            'review',\n            relationEngineReferenceToNamespace(this.props.taxon.ref),\n            this.props.taxon.ref.id,\n            String(this.props.taxon.ref.timestamp)\n        ].join('/');\n        // const hash = `review/${fixedID}`;\n        // TODO: use the integration api?\n        if (window.parent) {\n            window.parent.location.hash = hash;\n        } else {\n            window.location.hash = hash;\n        }\n        // window.history.pushState({}, 'my title', `/#review/${this.props.taxon.id}`);\n        // this.props.navigateToTaxonID(this.props.taxon.id);\n    }\n\n    onMouseEnter(ev: React.MouseEvent<HTMLDivElement>) {\n        this.setState({ hovering: true });\n    }\n\n    onMouseLeave(ev: React.MouseEvent<HTMLDivElement>) {\n        this.setState({ hovering: false });\n    }\n\n    renderOver() {\n        return (\n            <React.Fragment>\n                <div className=\"TaxonItem-name\" onClick={this.clickNavigateToTaxon.bind(this)}>\n                    {this.props.taxon.name}\n                </div>\n                <div className=\"TaxonItem-inspector\" onClick={this.clickTaxon.bind(this)}>\n                    <Icon type=\"arrow-right\" />\n                </div>\n            </React.Fragment>\n        );\n    }\n\n    renderActive() {\n        return (\n            <React.Fragment>\n                <div className=\"TaxonItem-name\" onClick={this.clickNavigateToTaxon.bind(this)}>\n                    {this.props.taxon.name}\n                </div>\n                <div className=\"TaxonItem-inspector\">\n                    <Icon type=\"arrow-right\" />\n                </div>\n            </React.Fragment>\n        );\n    }\n\n    renderNormal() {\n        return (\n            <React.Fragment>\n                <div className=\"TaxonItem-name\">{this.props.taxon.name}</div>\n            </React.Fragment>\n        );\n    }\n\n    renderItem() {\n        if (this.props.isActive) {\n            return this.renderActive();\n        }\n        if (this.state.hovering) {\n            return this.renderOver();\n        } else {\n            return this.renderNormal();\n        }\n    }\n\n    render() {\n        const taxon = this.props.taxon;\n        const classNames = ['TaxonItem'];\n        if (this.props.isActive) {\n            classNames.push('TaxonItem-active');\n        }\n\n        const tooltipTitle = (\n            <div>\n                <div style={{ borderBottom: '1px solid silver' }}>{taxon.name}</div>\n                <div>{taxon.rank}</div>\n            </div>\n        );\n\n        return (\n            <Tooltip title={tooltipTitle} placement=\"right\">\n                <div\n                    className={classNames.join(' ')}\n                    key={this.props.taxon.ref.id}\n                    onMouseEnter={this.onMouseEnter.bind(this)}\n                    onMouseLeave={this.onMouseLeave.bind(this)}\n                >\n                    {this.renderItem()}\n                </div>\n            </Tooltip>\n        );\n    }\n}\n","import DB, {\n    DBProps,\n    DBStatus,\n    DBStateNone,\n    DBStateLoading,\n    DBStateLoaded,\n    DBStateError,\n    DBStateReLoading\n} from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport { Taxon, TaxonomyReference } from '../../../types/taxonomy';\nimport { TaxonomyModel } from '../lib/model';\n\nexport type TaxonDBStateNone = DBStateNone;\nexport type TaxonDBStateLoading = DBStateLoading;\nexport type TaxonDBStateError = DBStateError;\n\nexport interface TaxonDBStateLoaded extends DBStateLoaded {\n    taxa: Array<Taxon>;\n    total: number;\n    page: number;\n    pageSize: number;\n}\n\nexport interface TaxonDBStateReLoading extends DBStateReLoading {\n    taxa: Array<Taxon>;\n    total: number;\n    page: number;\n    pageSize: number;\n}\n\nexport type TaxonDBState =\n    | TaxonDBStateNone\n    | TaxonDBStateLoading\n    | TaxonDBStateLoaded\n    | TaxonDBStateReLoading\n    | TaxonDBStateError;\n\nexport interface TaxonDBProps extends DBProps<TaxonDBState> {\n    token: string;\n    config: AppConfig;\n}\n\nexport default class TaxonChildrenDB extends DB<TaxonDBState> {\n    token: string;\n    serviceWizardURL: string;\n    constructor(props: TaxonDBProps) {\n        super(props);\n        this.token = props.token;\n        this.serviceWizardURL = props.config.services.ServiceWizard.url;\n    }\n    // Remember, pages are 1 based; offset is 0 based.\n    // async fetchTaxa(taxonID: TaxonID, page: number, pageSize: number) {\n    //     try {\n    //         this.set((state: TaxonDBState) => {\n    //             return {\n    //                 ...state,\n    //                 status: DBStatus.LOADING\n    //             };\n    //         });\n\n    //         const client = new TaxonomyModel({\n    //             token: this.token,\n    //             url: this.serviceWizardURL\n    //         });\n\n    //         const offset = (page - 1) * pageSize;\n    //         const limit = pageSize;\n\n    //         const [taxa, totalCount] = await client.getChildren(taxonID, {\n    //             offset,\n    //             limit\n    //         });\n    //         this.set((state: TaxonDBState) => {\n    //             return {\n    //                 ...state,\n    //                 status: DBStatus.LOADED,\n    //                 taxa,\n    //                 total: totalCount,\n    //                 page,\n    //                 pageSize\n    //             };\n    //         });\n    //     } catch (ex) {\n    //         console.error('ERROR', ex);\n    //         this.set((state: TaxonDBState) => {\n    //             return {\n    //                 status: DBStatus.ERROR,\n    //                 message: ex.message\n    //             };\n    //         });\n    //     }\n    // }\n\n    async fetchChildren({\n        taxonRef,\n        page,\n        pageSize,\n        searchTerm\n    }: {\n        taxonRef: TaxonomyReference;\n        page: number;\n        pageSize: number;\n        searchTerm: string;\n    }) {\n        try {\n            this.set((state: TaxonDBState) => {\n                if (state.status === DBStatus.LOADED) {\n                    return {\n                        ...state,\n                        status: DBStatus.RELOADING\n                    };\n                } else {\n                    return {\n                        ...state,\n                        status: DBStatus.LOADING\n                    };\n                }\n            });\n\n            const client = new TaxonomyModel({\n                token: this.token,\n                url: this.serviceWizardURL\n            });\n\n            const offset = (page - 1) * pageSize;\n            const limit = pageSize;\n\n            const [taxa, totalCount] = await client.getChildren(taxonRef, {\n                offset,\n                limit,\n                searchTerm\n            });\n            this.set((state: TaxonDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    taxa,\n                    total: totalCount,\n                    page,\n                    pageSize\n                };\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: TaxonDBState) => {\n                return {\n                    status: DBStatus.ERROR,\n                    error: {\n                        code: 'not-found',\n                        source: 'TaxonChildrenDB.fetchChildren',\n                        message: ex.message,\n                    }\n                };\n            });\n        }\n    }\n}\n","import React from 'react';\nimport { Taxon, TaxonomyReference } from '../../types/taxonomy';\nimport './TaxonList.css';\nimport TaxonItem from './TaxonItem';\nimport { Empty } from 'antd';\n\nexport interface Props {\n    taxa: Array<Taxon>;\n    maxItems: number;\n    totalItems: number;\n    selectedTaxonRef: TaxonomyReference | null;\n    selectTaxonRef: (ref: TaxonomyReference) => void;\n    navigateToTaxonRef: (ref: TaxonomyReference) => void;\n}\n\ninterface State { }\n\nexport default class TaxonList extends React.Component<Props, State> {\n    selectTaxon(ref: TaxonomyReference) {\n        this.props.selectTaxonRef(ref);\n    }\n    navigateToTaxon(ref: TaxonomyReference) {\n        this.props.navigateToTaxonRef(ref);\n    }\n    renderItemsPlain() {\n        return this.props.taxa.map((taxon, index) => {\n            const isActive = this.props.selectedTaxonRef !== null &&\n                this.props.selectedTaxonRef.id === taxon.ref.id;\n            return (\n                <TaxonItem\n                    taxon={taxon}\n                    isActive={isActive}\n                    selectTaxonRef={this.selectTaxon.bind(this)}\n                    key={String(index)}\n                    navigateToTaxonRef={this.navigateToTaxon.bind(this)}\n                />\n            );\n        });\n    }\n    renderNoItems() {\n        return <Empty description=\"No Children\" image={Empty.PRESENTED_IMAGE_SIMPLE} />;\n    }\n    render() {\n        if (this.props.taxa.length === 0) {\n            return this.renderNoItems();\n        }\n        return this.renderItemsPlain();\n    }\n}\n","import React from 'react';\nimport { UIError } from \"../types/error\";\nimport { Alert, Icon } from 'antd';\n\nexport interface ErrorViewProps {\n    error: UIError\n}\n\ninterface ErrorViewState {\n\n}\n\nexport default class ErrorView extends React.Component<ErrorViewProps, ErrorViewState> {\n    renderMessage() {\n        return (\n            // <Icon type=\"exclamation-circle\" />\n            <span>\n                <Icon type=\"exclamation-circle\" style={{ color: 'red' }} />\n                {' '}\n                {this.props.error.message}\n            </span>\n        )\n    }\n    render() {\n        return (\n            <Alert type=\"error\" message={this.renderMessage()}></Alert>\n        )\n    }\n}","import React from 'react';\nimport { Pagination, Icon, Input, Spin } from 'antd';\nimport TaxonList from '../TaxonList';\nimport { TaxonomyReference } from '../../../types/taxonomy';\nimport { TaxonDBState, TaxonDBStateError, TaxonDBStateLoaded, TaxonDBStateReLoading } from './TaxonChildrenDB';\nimport { DBStatus } from '../../../lib/DB';\nimport './index.css';\nimport ErrorView from '../../../components/ErrorView';\n\nconst DEFAULT_PAGE_SIZE = 10;\n\nexport interface Props {\n    db: TaxonDBState;\n    taxonRef: TaxonomyReference;\n    selectedTaxonRef: TaxonomyReference | null;\n    // taxa: Array<Taxon>;\n    // total: number;\n    selectTaxonRef: (taxonRef: TaxonomyReference) => void;\n    navigateToTaxonRef: (taxonRef: TaxonomyReference) => void;\n    fetchChildren: (taxonRef: TaxonomyReference, page: number, pageSize: number, searchTerm: string) => void;\n}\n\nexport interface State { }\n\nexport default class TaxonChildren extends React.Component<Props, State> {\n    searchTerm: string;\n    page: number;\n    pageSize: number | null;\n    constructor(props: Props) {\n        super(props);\n        this.searchTerm = '';\n        this.page = 1;\n        this.pageSize = null;\n    }\n    componentDidMount() {\n        this.props.fetchChildren(this.props.taxonRef, 1, DEFAULT_PAGE_SIZE, '');\n    }\n    renderTaxaNone() {\n        return <div>None</div>;\n    }\n    renderTaxaLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderTitleLoaded(db: TaxonDBStateLoaded | TaxonDBStateReLoading) {\n        if (db.total === 0) {\n            return <div className=\"Col-auto TaxonChildren-box-title\">No Children</div>;\n        }\n\n        const totalCount = Intl.NumberFormat('en-US', {\n            useGrouping: true\n        }).format(db.total);\n        const currentItem = (db.page - 1) * db.pageSize + 1;\n        const lastItem = currentItem + db.taxa.length - 1;\n\n        return (\n            <div className=\"Col-auto TaxonChildren-box-title\">\n                Children ({currentItem}-{lastItem} of {totalCount})\n            </div>\n        );\n    }\n\n    renderTitleReLoading(db: TaxonDBStateReLoading) {\n        return <Spin size=\"small\">{this.renderTitleLoaded(db)}</Spin>;\n    }\n\n    renderTitle() {\n        const db = this.props.db;\n        switch (db.status) {\n            case DBStatus.NONE:\n            case DBStatus.LOADING:\n                return <div>Loading...</div>;\n            case DBStatus.ERROR:\n                return <ErrorView error={db.error} />\n            case DBStatus.LOADED:\n                return this.renderTitleLoaded(db);\n            case DBStatus.RELOADING:\n                return this.renderTitleReLoading(db);\n        }\n    }\n    doSearch(term: string) {\n        this.searchTerm = term;\n        this.props.fetchChildren(this.props.taxonRef, 1, this.pageSize || DEFAULT_PAGE_SIZE, term);\n    }\n    renderSearch() {\n        const disabled =\n            this.props.db.status !== DBStatus.LOADED ||\n            (this.props.db.total <= this.props.db.pageSize && !this.searchTerm);\n        return (\n            <div style={{ marginBottom: '4px' }}>\n                <Input.Search placeholder=\"Search Children\" onSearch={this.doSearch.bind(this)} disabled={disabled} />\n            </div>\n        );\n    }\n    renderTaxaLoaded(db: TaxonDBStateLoaded | TaxonDBStateReLoading) {\n        return (\n            <React.Fragment>\n                <TaxonList\n                    taxa={db.taxa}\n                    selectedTaxonRef={this.props.selectedTaxonRef}\n                    selectTaxonRef={this.props.selectTaxonRef}\n                    navigateToTaxonRef={this.props.navigateToTaxonRef}\n                    totalItems={db.total}\n                    maxItems={DEFAULT_PAGE_SIZE}\n                />\n            </React.Fragment>\n        );\n    }\n    renderTaxaReLoading(db: TaxonDBStateReLoading) {\n        return <Spin tip=\"Loading\">{this.renderTaxaLoaded(db)}</Spin>;\n    }\n    renderTaxaError(db: TaxonDBStateError) {\n        return <ErrorView error={db.error} />\n    }\n    renderTaxa() {\n        switch (this.props.db.status) {\n            case DBStatus.NONE:\n                return this.renderTaxaNone();\n            case DBStatus.LOADING:\n                return this.renderTaxaLoading();\n            case DBStatus.LOADED:\n                return this.renderTaxaLoaded(this.props.db);\n            case DBStatus.RELOADING:\n                return this.renderTaxaReLoading(this.props.db);\n            case DBStatus.ERROR:\n                return this.renderTaxaError(this.props.db);\n        }\n    }\n    changePage(page: number, pageSize: number | undefined) {\n        this.page = page;\n        this.pageSize = pageSize || DEFAULT_PAGE_SIZE;\n        this.props.fetchChildren(this.props.taxonRef, this.page, this.pageSize, this.searchTerm);\n    }\n    renderPaginationNone() {\n        return <Pagination size=\"small\" showLessItems={true} hideOnSinglePage={false} />;\n    }\n    renderPaginationLoading() {\n        return <Pagination size=\"small\" showLessItems={true} hideOnSinglePage={false} />;\n    }\n    renderPaginationError() {\n        return <Pagination size=\"small\" showLessItems={true} hideOnSinglePage={false} />;\n    }\n    renderPaginationLoaded(db: TaxonDBStateLoaded) {\n        return (\n            <Pagination\n                size=\"small\"\n                defaultPageSize={db.pageSize}\n                // defaultCurrent={1}\n                showLessItems={true}\n                current={db.page}\n                hideOnSinglePage={false}\n                total={db.total}\n                onChange={this.changePage.bind(this)}\n            />\n        );\n    }\n    renderPaginationReLoading(db: TaxonDBStateReLoading) {\n        return (\n            <Pagination\n                size=\"small\"\n                defaultPageSize={db.pageSize}\n                // defaultCurrent={1}\n                showLessItems={true}\n                current={db.page}\n                hideOnSinglePage={false}\n                total={db.total}\n                disabled={true}\n            />\n        );\n    }\n    renderPagination() {\n        const db = this.props.db;\n        switch (db.status) {\n            case DBStatus.NONE:\n                return this.renderPaginationNone();\n            case DBStatus.LOADING:\n                return this.renderPaginationLoading();\n            case DBStatus.ERROR:\n                return this.renderPaginationError();\n            case DBStatus.LOADED:\n                return this.renderPaginationLoaded(db);\n            case DBStatus.RELOADING:\n                return this.renderPaginationReLoading(db);\n        }\n    }\n    renderChildren() {\n        return (\n            <div>\n                {this.renderTitle()}\n                {this.renderSearch()}\n                {this.renderPagination()}\n                {this.renderTaxa()}\n            </div>\n        );\n    }\n\n    render() {\n        return this.renderChildren();\n    }\n}\n","import React from 'react';\nimport TaxonDB, { TaxonDBState, TaxonDBStateError } from './TaxonChildrenDB';\nimport { DBStatus } from '../../../lib/DB';\n\nimport { AppConfig } from '@kbase/ui-components';\nimport TaxonChildren from './TaxonChildren';\nimport { TaxonomyReference } from '../../../types/taxonomy';\nimport { Alert } from 'antd';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    taxonRef: TaxonomyReference;\n    selectedTaxonRef: TaxonomyReference | null;\n    selectTaxonRef: (taxonRef: TaxonomyReference) => void;\n    navigateToTaxonRef: (taxonRef: TaxonomyReference) => void;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: TaxonDB;\n    constructor(props: Props) {\n        super(props);\n        this.db = new TaxonDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n    }\n\n    componentDidMount() {\n        // this.db.stop();\n    }\n\n    fetchChildren(taxonRef: TaxonomyReference, page: number, pageSize: number, searchTerm: string) {\n        return this.db.fetchChildren({ taxonRef, page, pageSize, searchTerm });\n    }\n\n    renderSuccess(db: TaxonDBState) {\n        return <TaxonChildren\n            db={db}\n            taxonRef={this.props.taxonRef}\n            selectedTaxonRef={this.props.selectedTaxonRef}\n            selectTaxonRef={this.props.selectTaxonRef}\n            navigateToTaxonRef={this.props.navigateToTaxonRef}\n            fetchChildren={this.fetchChildren.bind(this)}\n        />\n    }\n\n    renderError(db: TaxonDBStateError) {\n        return <Alert type=\"error\" message={db.error.message} />\n    }\n\n    renderTest() {\n        return \"test\";\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case (DBStatus.ERROR):\n                return this.renderError(db);\n            default:\n                // return this.renderTest()\n                return this.renderSuccess(db);\n        }\n    }\n}\n","import { AppConfig } from '@kbase/ui-components';\nimport { StoreState } from '../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps { }\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps() {\n    return {};\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import DB, { DBProps, DBStatus, DBStateNone, DBStateLoading, DBStateLoaded, DBStateError } from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport { Taxon, TaxonomyReference } from '../../../types/taxonomy';\nimport { TaxonomyModel } from '../lib/model';\n\nexport type LineageDBStateNone = DBStateNone;\nexport type LineageDBStateLoading = DBStateLoading;\nexport type LineageDBStateError = DBStateError;\n\nexport interface LineageDBStateLoaded extends DBStateLoaded {\n    lineage: Array<Taxon>;\n}\n\nexport type LineageDBState = LineageDBStateNone | LineageDBStateLoading | LineageDBStateLoaded | LineageDBStateError;\n\nexport interface LineageDBProps extends DBProps<LineageDBState> {\n    token: string;\n    config: AppConfig;\n}\n\n// TODO: make props part of generic\nexport default class LineageDB extends DB<LineageDBState> {\n    props: LineageDBProps;\n    constructor(props: LineageDBProps) {\n        super(props);\n        this.props = props;\n    }\n    async getLineage(taxonRef: TaxonomyReference) {\n        try {\n            this.set((state: LineageDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADING\n                };\n            });\n\n            const client = new TaxonomyModel({\n                token: this.props.token,\n                url: this.props.config.services.ServiceWizard.url\n            });\n            const lineage = await client.getLineage(taxonRef);\n            this.set((state: LineageDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    lineage\n                };\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: LineageDBState) => {\n                return {\n                    status: DBStatus.ERROR,\n                    error: {\n                        code: 'not-found',\n                        source: 'LineageDB.getLineage',\n                        message: ex.message,\n                    }\n                };\n            });\n        }\n    }\n}\n","import React from 'react';\nimport { Taxon, TaxonomyReference } from '../../../types/taxonomy';\nimport TaxonList from '../TaxonList';\n\nexport interface Props {\n    lineage: Array<Taxon>;\n    selectedTaxonRef: TaxonomyReference;\n    selectTaxonRef: (ref: TaxonomyReference) => void;\n    navigateToTaxonRef: (ref: TaxonomyReference) => void;\n}\n\ninterface State { }\n\nexport default class Lineage extends React.Component<Props, State> {\n    render() {\n        return (\n            <TaxonList\n                taxa={this.props.lineage}\n                selectedTaxonRef={this.props.selectedTaxonRef}\n                selectTaxonRef={this.props.selectTaxonRef}\n                navigateToTaxonRef={this.props.navigateToTaxonRef}\n                totalItems={this.props.lineage.length}\n                maxItems={10}\n            />\n        );\n    }\n}\n","import React from 'react';\nimport LineageDB, { LineageDBStateLoaded } from './LineageDB';\nimport { DBStatus, DBStateError } from '../../../lib/DB';\n\nimport { AppConfig } from '@kbase/ui-components';\nimport Lineage from './Lineage';\nimport { TaxonomyReference } from '../../../types/taxonomy';\nimport { Icon } from 'antd';\nimport ErrorView from '../../../components/ErrorView';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    taxonRef: TaxonomyReference;\n    selectedTaxonRef: TaxonomyReference;\n    selectTaxonRef: (taxonRef: TaxonomyReference) => void;\n    navigateToTaxonRef: (taxonRef: TaxonomyReference) => void;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: LineageDB;\n    constructor(props: Props) {\n        super(props);\n        this.db = new LineageDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n    }\n\n    componentDidMount() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                this.db.getLineage(this.props.taxonRef);\n        }\n    }\n\n    componentWillUnmount() {\n        // this.db.stop();\n    }\n\n    renderLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderError(db: DBStateError) {\n        return <ErrorView error={db.error} />\n    }\n\n    renderLoaded(db: LineageDBStateLoaded) {\n        return (\n            <Lineage\n                lineage={db.lineage}\n                selectedTaxonRef={this.props.selectedTaxonRef}\n                selectTaxonRef={this.props.selectTaxonRef}\n                navigateToTaxonRef={this.props.navigateToTaxonRef}\n            />\n        );\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                // this.db.getLineage(this.props.taxonRef);\n                return this.renderLoading();\n            case DBStatus.LOADING:\n                return this.renderLoading();\n            case DBStatus.ERROR:\n                return this.renderError(db);\n            case DBStatus.LOADED:\n                return this.renderLoaded(db);\n        }\n    }\n}\n","import { AppConfig } from '@kbase/ui-components';\nimport { StoreState } from '../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps { }\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps() {\n    return {};\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import React from 'react';\nimport { Taxon, TaxonomyReference } from '../../types/taxonomy';\nimport './LineageNavigator.css';\nimport TaxonItem from './TaxonItem';\nimport TaxonChildren from './taxonChildren';\nimport Lineage from './lineage';\n\nexport interface LineageProps {\n    selectedTaxon: Taxon;\n    targetTaxon: Taxon;\n    selectTaxonRef: (ref: TaxonomyReference) => void;\n    navigateToTaxonRef: (ref: TaxonomyReference) => void;\n}\n\ninterface LineageState { }\n\nexport default class LineageNavigator extends React.Component<LineageProps, LineageState> {\n    onClick(ref: TaxonomyReference) {\n        this.props.selectTaxonRef(ref);\n        // alert('navigate to ' + taxonId);\n    }\n\n    // menuSelected(param: SelectParam) {\n    //     this.props.selectTaxonRef(param.key);\n    //     // alert('navigate to ' + param.key);\n    // }\n\n    clickTaxon(taxon: Taxon) {\n        this.props.selectTaxonRef(taxon.ref);\n    }\n\n    renderLineage() {\n        return (\n            <Lineage\n                taxonRef={this.props.targetTaxon.ref}\n                selectedTaxonRef={this.props.selectedTaxon.ref}\n                selectTaxonRef={this.props.selectTaxonRef}\n                navigateToTaxonRef={this.props.navigateToTaxonRef}\n            />\n        );\n        // return 'disabled';\n    }\n\n    renderChildrenCount(count: number) {\n        if (count === 0) {\n            return <div className=\"\">No children</div>;\n        }\n        if (count === 1) {\n            return <div>One child</div>;\n        }\n        return (\n            <div>\n                {Intl.NumberFormat('en-US', {\n                    useGrouping: true\n                }).format(count)}{' '}\n                children\n            </div>\n        );\n    }\n\n    renderChildren() {\n        let selectedRef: TaxonomyReference | null;\n        if (this.props.selectedTaxon) {\n            selectedRef = this.props.selectedTaxon.ref;\n        } else {\n            selectedRef = null;\n        }\n\n        return (\n            <TaxonChildren\n                taxonRef={this.props.targetTaxon.ref}\n                selectedTaxonRef={selectedRef}\n                selectTaxonRef={this.props.selectTaxonRef}\n                navigateToTaxonRef={this.props.navigateToTaxonRef}\n            />\n        );\n    }\n\n    // renderChildrenxscrolling() {\n    //     let selectedId;\n    //     if (this.props.selectedTaxon) {\n    //         selectedId = this.props.selectedTaxon.id;\n    //     } else {\n    //         selectedId = null;\n    //     }\n\n    //     return (\n    //         <div className=\"scrolling\">\n    //             <TaxonList\n    //                 taxa={this.props.offspring}\n    //                 selectedTaxonID={selectedId}\n    //                 selectTaxonID={this.props.selectTaxonID}\n    //                 navigateToTaxonID={this.props.navigateToTaxonID}\n    //                 totalItems={this.props.totalOffspring}\n    //                 maxItems={10}\n    //             />\n    //         </div>\n    //     );\n    // }\n\n    renderTargetTaxon() {\n        const isActive =\n            this.props.selectedTaxon &&\n            this.props.selectedTaxon.ref.id === this.props.targetTaxon.ref.id &&\n            this.props.selectedTaxon.ref.timestamp === this.props.targetTaxon.ref.timestamp;\n\n        return (\n            <TaxonItem\n                taxon={this.props.targetTaxon}\n                isActive={isActive}\n                selectTaxonRef={this.props.selectTaxonRef}\n                navigateToTaxonRef={this.props.navigateToTaxonRef}\n            />\n        );\n    }\n\n    render() {\n        return (\n            <div className=\"Col scrollable\" style={{ overflowY: 'auto' }}>\n                <div className=\"Col-auto Nav-box\">\n                    <div className=\"Nav-box-title\">Lineage</div>\n                    {this.renderLineage()}\n                </div>\n                <div className=\"Col-auto Nav-box Lineage-target-taxon\">{this.renderTargetTaxon()}</div>\n                <div className=\"Col-auto scrollable Nav-box\">{this.renderChildren()}</div>\n            </div>\n        );\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { Taxon } from '../../types/taxonomy';\n\nexport interface Props {\n    taxon: Taxon;\n}\n\nexport interface State { }\n\nexport default class TaxonSummary extends React.Component<Props, State> {\n    render() {\n        let nameStyle: CSSProperties = {};\n        if (this.props.taxon.rank === 'species') {\n            nameStyle = { fontStyle: 'italic' };\n        }\n        return (\n            <div className=\"InfoTable\">\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                        Name\n                    </div>\n                    <div className=\"InfoTable-dataCol\" style={nameStyle}>\n                        {this.props.taxon.name}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                        Rank\n                    </div>\n                    <div className=\"InfoTable-dataCol\">{this.props.taxon.rank}</div>\n                </div>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport { NCBITaxon, TaxonAlias } from '../../../types/taxonomy';\nimport { Table } from 'antd';\nimport geneticCodes from '../data/geneticCodes.json';\n\n// as Array<[number, string]>\n\ntype GeneticCodes = Array<[number, string]>;\n\nfunction ensureGeneticCodes(geneticCodes: any): GeneticCodes {\n    if (!(geneticCodes instanceof Array)) {\n        throw new Error('Invalid genetic codes file!');\n    }\n\n    return geneticCodes.map(([id, name]) => {\n        if (typeof id !== 'number') {\n            throw new Error('Invalid genetic code id in file');\n        }\n        if (typeof name !== 'string') {\n            throw new Error('Invalid genetic code label in file');\n        }\n        return [id, name];\n    });\n}\n\nconst gc = ensureGeneticCodes(geneticCodes);\n\nconst geneticCodesMap: Map<number, string> = gc.reduce((geneticCodesMap, [id, label]) => {\n    geneticCodesMap.set(id, label);\n    return geneticCodesMap;\n}, new Map<number, string>());\n\nexport interface TaxonDetailProps {\n    taxon: NCBITaxon;\n}\n\ninterface TaxonDetailState { }\n\nexport default class TaxonDetailNCBI extends React.Component<TaxonDetailProps, TaxonDetailState> {\n    renderAliases() {\n        const aliasNameSorter = (a: TaxonAlias, b: TaxonAlias) => {\n            return stringSorter(a.name, b.name);\n        };\n\n        const aliasCategorySorter = (a: TaxonAlias, b: TaxonAlias) => {\n            return stringSorter(a.category, b.category);\n        };\n\n        const stringSorter = (a: string, b: string) => {\n            const fixedA = a.replace(/^[\"']/, '');\n            const fixedB = b.replace(/^[\"']/, '');\n            return fixedA.localeCompare(fixedB);\n        };\n        return (\n            <Table\n                dataSource={this.props.taxon.aliases}\n                className=\"KBaseAntdOverride-remove-table-border\"\n                size=\"small\"\n                // pagination={{ position: 'top' }}\n                pagination={false}\n                scroll={{ y: '25em' }}\n                rowKey=\"name\"\n                bordered={false}\n            >\n                <Table.Column\n                    title=\"Name\"\n                    dataIndex=\"name\"\n                    key=\"name\"\n                    defaultSortOrder=\"ascend\"\n                    sorter={aliasNameSorter}\n                />\n                <Table.Column\n                    title=\"Category\"\n                    dataIndex=\"category\"\n                    key=\"category\"\n                    width=\"20em\"\n                    sorter={aliasCategorySorter}\n                />\n            </Table>\n        );\n    }\n\n    renderTaxonDetail() {\n        const width = '8em';\n        let nameStyle: React.CSSProperties = {};\n        if (this.props.taxon.rank === 'species') {\n            nameStyle.fontStyle = 'italic';\n        }\n        return (\n            <div className=\"InfoTable\">\n                <div className=\"InfoTable-row\" key=\"name\">\n                    <div className=\"InfoTable-labelCol\" style={{ width }}>\n                        Name\n                    </div>\n                    <div className=\"InfoTable-dataCol\" style={nameStyle}>\n                        {this.props.taxon.name}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\" key=\"rank\">\n                    <div className=\"InfoTable-labelCol\" style={{ width }}>\n                        Rank\n                    </div>\n                    <div className=\"InfoTable-dataCol\">{this.props.taxon.rank}</div>\n                </div>\n                <div className=\"InfoTable-row\" key=\"ncbiid\">\n                    <div className=\"InfoTable-labelCol\" style={{ width }}>\n                        NCBI ID\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        <a\n                            href={`https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=info&id=${\n                                this.props.taxon.ncbiID\n                                }`}\n                            target=\"_blank\"\n                            rel=\"noopener noreferrer\"\n                        >\n                            {this.props.taxon.ncbiID}\n                        </a>\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\" key=\"genetic-code\">\n                    <div className=\"InfoTable-labelCol\" style={{ width }}>\n                        Genetic Code\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.props.taxon.geneticCode} -{' '}\n                        {geneticCodesMap.get(this.props.taxon.geneticCode) || 'Unknown'}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\" key=\"aliases\">\n                    <div className=\"InfoTable-labelCol\" style={{ width }}>\n                        Aliases\n                    </div>\n                    <div className=\"InfoTable-dataCol\">{this.renderAliases()}</div>\n                </div>\n            </div>\n        );\n    }\n\n    render() {\n        return <div>{this.renderTaxonDetail()}</div>;\n    }\n}\n","import React from 'react';\nimport { Taxon, NCBITaxon } from '../../../types/taxonomy';\nimport TaxonDetailNCBI from './TaxonDetailNCBI';\nimport { Alert } from 'antd';\nimport { RelationEngineDataSource } from '../../../types/core';\n\nexport interface TaxonDetailProps {\n    taxon: Taxon;\n}\n\ninterface TaxonDetailState { }\n\nexport default class TaxonDetail extends React.Component<TaxonDetailProps, TaxonDetailState> {\n    render() {\n        const taxon = this.props.taxon;\n        switch (taxon.ref.dataSource) {\n            case RelationEngineDataSource.NCBI:\n                // TODO: why does this not prove to TS that we have a NCBITaxon?\n                return <TaxonDetailNCBI taxon={taxon as NCBITaxon} />;\n            default:\n                return <Alert type=\"error\" message=\"This taxon type is not supported\" />;\n        }\n    }\n}\n","export function getProp<T>(obj: object, propPath: string | Array<string>, defaultValue: any): T {\n    if (typeof propPath === 'string') {\n        propPath = propPath.split('.');\n    } else if (!(propPath instanceof Array)) {\n        throw new TypeError('Invalid type for key: ' + typeof propPath);\n    }\n    let temp: any = obj;\n    for (let i = 0; i < propPath.length; i += 1) {\n        if (temp === undefined || typeof temp !== 'object' || temp === null) {\n            return defaultValue;\n        }\n        temp = temp[propPath[i]];\n    }\n    if (temp === undefined) {\n        return defaultValue;\n    }\n    return temp;\n}\n\nexport function hasProp(obj: object, propPath: string | Array<string>): boolean {\n    if (typeof propPath === 'string') {\n        propPath = propPath.split('.');\n    } else if (!(propPath instanceof Array)) {\n        throw new TypeError('Invalid type for key: ' + typeof propPath);\n    }\n    let temp: any = obj;\n    for (let i = 0; i < propPath.length; i += 1) {\n        if (temp === undefined || typeof temp !== 'object' || temp === null) {\n            return false;\n        }\n        temp = temp[propPath[i]];\n    }\n    if (temp === undefined) {\n        return false;\n    }\n    return true;\n}\n\nexport function setProp(obj: object, propPath: string | Array<string>, value: any) {\n    if (typeof propPath === 'string') {\n        propPath = propPath.split('.');\n    } else if (!(propPath instanceof Array)) {\n        throw new TypeError('Invalid type for key: ' + typeof propPath);\n    }\n    if (propPath.length === 0) {\n        return;\n    }\n    // pop off the last property for setting at the end.\n    const propKey = propPath[propPath.length - 1];\n    let key;\n    // Walk the path, creating empty objects if need be.\n    let temp: any = obj;\n    for (let i = 0; i < propPath.length - 1; i += 1) {\n        key = propPath[i];\n        if (temp[key] === undefined) {\n            temp[key] = {};\n        }\n        obj = temp[key];\n    }\n    // Finally set the property.\n    temp[propKey] = value;\n    return value;\n}\n\nexport function incrProp(obj: object, propPath: string | Array<string>, increment: number): number | undefined {\n    if (typeof propPath === 'string') {\n        propPath = propPath.split('.');\n    } else if (!(propPath instanceof Array)) {\n        throw new TypeError('Invalid type for key: ' + typeof propPath);\n    }\n    if (propPath.length === 0) {\n        return;\n    }\n    increment = increment === undefined ? 1 : increment;\n    const propKey = propPath[propPath.length - 1];\n    let temp: any = obj;\n    for (let i = 0; i < propPath.length - 1; i += 1) {\n        const key = propPath[i];\n        if (temp[key] === undefined) {\n            temp[key] = {};\n        }\n        temp = temp[key];\n    }\n    if (temp[propKey] === undefined) {\n        temp[propKey] = increment;\n    } else {\n        if (typeof temp[propKey] === 'number') {\n            temp[propKey] += increment;\n        } else {\n            throw new Error('Can only increment a number');\n        }\n    }\n    return temp[propKey];\n}\n\nexport function deleteProp(obj: object, propPath: string | Array<string>) {\n    if (typeof propPath === 'string') {\n        propPath = propPath.split('.');\n    } else if (!(propPath instanceof Array)) {\n        throw new TypeError('Invalid type for key: ' + typeof propPath);\n    }\n    if (propPath.length === 0) {\n        return false;\n    }\n    const propKey = propPath[propPath.length - 1];\n    let temp: any = obj;\n    for (let i = 0; i < propPath.length - 1; i += 1) {\n        const key = propPath[i];\n        if (temp[key] === undefined) {\n            // for idempotency, and utility, do not throw error if\n            // the key doesn't exist.\n            return false;\n        }\n        obj = temp[key];\n    }\n    if (temp[propKey] === undefined) {\n        return false;\n    }\n    delete temp[propKey];\n    return true;\n}\n\n// class Props {\n//     constructor(config = {}) {\n//         this.obj = config.data || {};\n//     }\n\n//     getItem(props, defaultValue) {\n//         return getProp(this.obj, props, defaultValue);\n//     }\n\n//     hasItem(propPath) {\n//         return hasProp(this.obj, propPath);\n\n//     }\n\n//     setItem(path, value) {\n//         return setProp(this.obj, path, value);\n//     }\n\n//     incrItem(path, increment) {\n//         return incrProp(this.obj, path, increment);\n//     }\n\n//     deleteItem(path) {\n//         return deleteProp(this.obj, path);\n//     }\n\n//     getRaw() {\n//         return this.obj;\n//     }\n// }\n\n// return Object.freeze({ Props, getProp, hasProp, setProp, incrProp, deleteProp });\n","import React from 'react';\n\nimport WikipediaClient, { WikipediaInfo } from '../landingPages/taxonomy/lib/Wikipedia';\nimport marked from 'marked';\nimport { Icon, Alert, Tooltip } from 'antd';\nimport Loading from './Loading';\nimport './Wikipedia.css';\n\nexport interface WikipediaProps {\n    term: string;\n}\n\nenum AsyncComponentLoadingState {\n    NONE,\n    LOADING,\n    LOADED,\n    ERROR\n}\n\ninterface StateNone {\n    state: AsyncComponentLoadingState.NONE;\n}\n\ninterface StateLoading {\n    state: AsyncComponentLoadingState.LOADING;\n}\n\ninterface StateLoaded {\n    state: AsyncComponentLoadingState.LOADED;\n    wikipediaInfo: WikipediaInfo;\n}\n\ninterface StateError {\n    state: AsyncComponentLoadingState.ERROR;\n    error: string;\n}\n\ntype WikipediaState = StateNone | StateLoading | StateLoaded | StateError;\n\nexport default class Wikipedia extends React.Component<WikipediaProps, WikipediaState> {\n    wikipediaClient: WikipediaClient;\n    canceled: boolean;\n    constructor(props: WikipediaProps) {\n        super(props);\n        this.wikipediaClient = new WikipediaClient();\n        this.canceled = false;\n        this.state = {\n            state: AsyncComponentLoadingState.NONE\n        };\n    }\n\n    componentWillUnmount() {\n        this.canceled = true;\n        // this.state = {\n        //     state: AsyncComponentLoadingState.CANCELED\n        // };\n    }\n\n    renderArticle(wikipediaInfo: WikipediaInfo) {\n        const content = marked(wikipediaInfo.introText);\n        return <div style={{ overflow: 'auto' }} dangerouslySetInnerHTML={{ __html: content }} />;\n    }\n\n    renderImage(wikipediaInfo: WikipediaInfo) {\n        if (!wikipediaInfo.imageUrl) {\n            return (\n                <div className=\"Wikipedia-empty-image\">\n                    <div className=\"-content\">Image not found</div>\n                </div>\n            );\n        }\n        return (\n            <div>\n                <img src={wikipediaInfo.imageUrl} style={{ width: '100%' }} alt={`${this.props.term}`} />\n            </div>\n        );\n    }\n\n    renderMatch(wikipediaInfo: WikipediaInfo) {\n        if (wikipediaInfo.exactMatch) {\n            const message = (\n                <React.Fragment>\n                    <Icon type=\"check\" style={{ color: 'green' }} /> Exact match on \"\n                    {wikipediaInfo.matchingTerms.join(' ')}\"\n                </React.Fragment>\n            );\n            return <Alert type=\"success\" message={message} />;\n        } else {\n            const message = (\n                <React.Fragment>\n                    <Icon type=\"warning\" style={{ color: 'orange' }} /> Inexact match on: \"\n                    {wikipediaInfo.matchingTerms.join(' ')}\"\n                </React.Fragment>\n            );\n            return <Alert type=\"warning\" message={message} />;\n        }\n    }\n\n    renderWikipediaLogoCredit() {\n        return (\n            <div>\n                <div style={{ borderBottom: '1px solid gray' }}>Link to the original Wikipedia entry</div>\n                <div style={{ fontSize: '80%' }}>\n                    <p style={{ textAlign: 'center' }}>\n                        credit:\n                        <a\n                            href=\"https://creativecommons.org/licenses/by-sa/3.0/\"\n                            title=\"Creative Commons Attribution-ShareAlike 3.0\"\n                            target=\"_blank\"\n                            rel=\"noopener noreferrer\"\n                        >\n                            CC BY-SA 3.0\n                        </a>\n                        <a\n                            href=\"https://en.wikipedia.org/w/index.php?curid=33285413\"\n                            target=\"_blank\"\n                            rel=\"noopener noreferrer\"\n                        >\n                            Link\n                        </a>\n                    </p>\n                </div>\n            </div>\n        );\n    }\n\n    renderWikipediaInfo(wikipediaInfo: WikipediaInfo) {\n        return (\n            <div className=\"Row scrollable\">\n                <div className=\"Col Col-grow-2 scrollable\">\n                    <div style={{ display: 'flex', flexDirection: 'row', marginBottom: '10px' }}>\n                        <div style={{ flex: '1 1 0px' }}>{this.renderMatch(wikipediaInfo)}</div>\n                        <div style={{ flex: '0 0 auto', alignSelf: 'center', marginLeft: '10px' }}>\n                            <div style={{ height: '32px', textAlign: 'center' }}>\n                                <Tooltip title={this.renderWikipediaLogoCredit()}>\n                                    <a href={wikipediaInfo.pageUrl} target=\"_blank\" rel=\"noopener noreferrer\">\n                                        <img\n                                            src=\"images/wikipedia-logo.svg\"\n                                            style={{ height: '100%' }}\n                                            alt=\"Wikipedia Logo\"\n                                        />\n                                    </a>\n                                </Tooltip>\n                            </div>\n                            <div />\n                        </div>\n                    </div>\n                    <div\n                        className=\"scrollable\"\n                        style={{ flex: '2 1 0px', paddingRight: '4px', marginRight: '4px', overflowY: 'auto' }}\n                    >\n                        {this.renderArticle(wikipediaInfo)}\n                    </div>\n                </div>\n\n                <div className=\"Col Col-grow-1\" style={{ flex: '1 1 0px', marginLeft: '10px' }}>\n                    {this.renderImage(wikipediaInfo)}\n                </div>\n            </div>\n        );\n    }\n\n    updateInfo() {\n        const wikipediaClient = new WikipediaClient();\n        const { term } = this.props;\n        this.setState({\n            state: AsyncComponentLoadingState.LOADING\n        });\n        wikipediaClient\n            .findTerm(term)\n            .then((wikipediaInfo) => {\n                if (this.canceled) {\n                    return;\n                }\n                this.setState({\n                    state: AsyncComponentLoadingState.LOADED,\n                    wikipediaInfo\n                });\n            })\n            .catch((err) => {\n                if (this.canceled) {\n                    return;\n                }\n                return this.setState({\n                    state: AsyncComponentLoadingState.ERROR,\n                    error: err.message\n                });\n            });\n    }\n\n    componentDidMount() {\n        this.updateInfo();\n    }\n\n    componentDidUpdate(props: WikipediaProps, state: WikipediaState) {\n        if (props.term !== this.props.term) {\n            this.updateInfo();\n        }\n    }\n\n    renderNone() {\n        return <div />;\n    }\n\n    renderLoading() {\n        return <Loading message=\"Searching Wikipedia...\" />;\n    }\n\n    renderLoaded(state: StateLoaded) {\n        return this.renderWikipediaInfo(state.wikipediaInfo);\n    }\n\n    renderError(state: StateError) {\n        return <Alert type=\"error\" message={state.error} />;\n    }\n\n    render() {\n        if (this.canceled) {\n            return;\n        }\n        switch (this.state.state) {\n            case AsyncComponentLoadingState.NONE:\n                return this.renderNone();\n            case AsyncComponentLoadingState.LOADING:\n                return this.renderLoading();\n            case AsyncComponentLoadingState.LOADED:\n                return this.renderLoaded(this.state);\n            case AsyncComponentLoadingState.ERROR:\n                return this.renderError(this.state);\n        }\n    }\n}\n","import * as props from './props';\n\nexport interface WikipediaInfo {\n    imageUrl: string;\n    pageUrl: string;\n    introText: string;\n    title: string;\n    pageId: number;\n    exactMatch: boolean;\n    matchingTerms: Array<string>;\n}\n\ninterface WikipediaParse {\n    headhtml: Map<string, string>;\n    pageid: number;\n    redirects: Array<string>;\n    text: Map<string, string>;\n    title: string;\n}\n\nclass NotFound extends Error {\n    constructor(message: string) {\n        super(message);\n\n        this.name = 'NotFound';\n    }\n}\n\nconst WIKIPEDIA_API_URL = 'https://en.wikipedia.org/w/api.php';\nconst IMAGE_SIZE = 500;\n\nexport default class Wikipedia {\n    scrubTerm(proposedTerm: string): string {\n        // convervatively, remove all non-alpha characters\n        const chars = proposedTerm.split('');\n        const validChar = /[\\w \\s]/;\n        const newChars = chars.filter((char) => {\n            if (validChar.exec(char)) {\n                return true;\n            }\n            return false;\n        });\n        return newChars.join('');\n    }\n\n    async findTerm(term: string): Promise<WikipediaInfo> {\n        if (!term) {\n            throw new Error('Empty term passed');\n        }\n        const lookupTerm = this.scrubTerm(term);\n        return this.getWikipediaInfo(lookupTerm).then(\n            ({ imageUrl, pageUrl, introText, title, pageId, matchingTerms, exactMatch }) => {\n                // this.imageUrl(imageUrl);\n                // this.pageUrl(url);\n                const fixedIntroText = introText\n                    .replace(/====/g, '####')\n                    .replace(/===/g, '###')\n                    .replace(/==/g, '##')\n                    .replace(/\\n/g, '  \\n');\n\n                return { imageUrl, pageUrl, introText: fixedIntroText, title, pageId, matchingTerms, exactMatch };\n            }\n        );\n    }\n\n    async getWikipediaInfo(term: string): Promise<WikipediaInfo> {\n        return this.getPage(term).then(\n            ({\n                wikiResponse,\n                matchingTerms,\n                exactMatch\n            }: {\n                wikiResponse: any;\n                matchingTerms: Array<string>;\n                exactMatch: boolean;\n            }) => {\n                // this.imageCaption(wikiResponse.parse.title);\n                return Promise.all([\n                    this.getImage({ size: IMAGE_SIZE, pageId: wikiResponse.parse.pageid }),\n                    this.getPageInfo({ pageId: wikiResponse.parse.pageid })\n                ]).then(([imageUrl, pageInfo]) => {\n                    return {\n                        imageUrl: imageUrl,\n                        pageUrl: pageInfo.url,\n                        introText: pageInfo.introText,\n                        title: wikiResponse.parse.title,\n                        pageId: wikiResponse.parse.pageid,\n                        matchingTerms,\n                        exactMatch\n                    };\n                });\n            }\n        );\n    }\n\n    // see: https://www.mediawiki.org/wiki/API:Main_page\n    // https://en.wikipedia.org/w/api.php?action=help&modules=parse\n    async getPage(term: string): Promise<{ wikiResponse: any; matchingTerms: Array<string>; exactMatch: boolean }> {\n        const terms = term.split(/\\s+/);\n        let matchingTerms: Array<string>;\n        let exactMatch = true;\n        return new Promise((resolve, reject) => {\n            const fetchPage = (terms: Array<string>) => {\n                if (terms.length === 0) {\n                    reject(new NotFound('No Wikipedia page found matching \"' + term + '\"'));\n                    // resolve(null);\n                }\n                // const http = new HttpClient.HttpClient();\n                // const header = new HttpClient.HttpHeader({\n                //     accept: 'application/json'\n                // });\n                const apiUrl = new URL(WIKIPEDIA_API_URL);\n                const query = apiUrl.searchParams;\n                query.set('action', 'parse');\n                query.set('format', 'json');\n                query.set('prop', 'text|headhtml');\n                query.set('section', '0');\n                query.set('redirects', '');\n                query.set('page', terms.join(' '));\n                const headers = {\n                    accept: 'application/json'\n                };\n                // must set this to enable cors\n                query.set('origin', '*');\n                fetch(apiUrl.toString(), {\n                    method: 'GET',\n                    headers\n                })\n                    .then((result) => {\n                        switch (result.status) {\n                            case 200:\n                                try {\n                                    return result.json().then((wikiResponse) => {\n                                        if (wikiResponse.error) {\n                                            if (wikiResponse.error.code === 'missingtitle') {\n                                                terms.pop();\n                                                exactMatch = false;\n                                                fetchPage(terms);\n                                                return null;\n                                            } else {\n                                                console.error('wikipedia api error', wikiResponse);\n                                                reject(new Error('Wikipedia api error: ' + wikiResponse.error.code));\n                                            }\n                                        } else {\n                                            matchingTerms = terms;\n                                            resolve({\n                                                wikiResponse,\n                                                matchingTerms,\n                                                exactMatch\n                                            });\n                                        }\n                                    });\n                                } catch (ex) {\n                                    reject(new Error('Error parsing wikipedia response: ' + ex.message));\n                                }\n                                break;\n                            default:\n                                const message = 'Unexpected response from wikipedia api: ' + result.status;\n                                console.error(message, result);\n                                reject(new Error(message));\n                        }\n                    })\n                    .catch((err) => {\n                        reject(err);\n                    });\n            };\n            fetchPage(terms);\n        });\n    }\n\n    async getPageInfo({ pageId }: { pageId: string }): Promise<any> {\n        const apiURL = new URL(WIKIPEDIA_API_URL);\n        const query = apiURL.searchParams;\n        query.set('action', 'query');\n        query.set('pageids', pageId);\n        query.set('prop', 'info|extracts');\n        query.set('explaintext', 'true');\n        query.set('inprop', 'url');\n        query.set('origin', '*');\n        query.set('format', 'json');\n\n        // const http = new HttpClient.HttpClient();\n        return fetch(apiURL.toString(), {\n            method: 'GET'\n        }).then((result) => {\n            switch (result.status) {\n                case 200:\n                    try {\n                        return result.json().then((wikiResponse) => {\n                            return {\n                                url: props.getProp<string>(\n                                    wikiResponse,\n                                    ['query', 'pages', String(pageId), 'fullurl'],\n                                    null\n                                ),\n                                introText: props.getProp<string>(\n                                    wikiResponse,\n                                    ['query', 'pages', String(pageId), 'extract'],\n                                    null\n                                )\n                            };\n                        });\n                    } catch (ex) {\n                        console.error('error getting page info', ex.message);\n                        throw ex;\n                    }\n                default:\n                    var message = 'Unexpected response from wikipedia api: ' + result.status;\n                    console.error(message, result);\n                    throw new Error(message);\n            }\n        });\n    }\n\n    async getImage({ size, pageId }: { size: number; pageId: number }): Promise<string> {\n        const apiURL = new URL(WIKIPEDIA_API_URL);\n        const query = apiURL.searchParams;\n        query.set('action', 'query');\n        query.set('format', 'json');\n        query.set('prop', 'pageimages');\n        query.set('pithumbsize', String(size));\n        query.set('pageids', String(pageId));\n        query.set('origin', '*');\n        const headers = {\n            accept: 'application/json'\n        };\n\n        return fetch(apiURL.toString(), {\n            method: 'GET',\n            headers\n        })\n            .then((result) => {\n                switch (result.status) {\n                    case 200:\n                        try {\n                            return result.json().then((wikiResponse) => {\n                                return props.getProp<string>(\n                                    wikiResponse,\n                                    ['query', 'pages', String(pageId), 'thumbnail', 'source'],\n                                    null\n                                );\n                            });\n                        } catch (ex) {\n                            throw new Error('Error parsing wikipedia response: ' + ex.message);\n                        }\n                    default:\n                        var message = 'Unexpected response from wikipedia api: ' + result.status;\n                        console.error(message, result);\n                        throw new Error(message);\n                }\n            })\n            .catch((err) => {\n                const message = 'Error getting image from wikipedia: ' + err.message;\n                console.error(message, err);\n                throw new Error('Error getting image from wikipedia: ' + err.message);\n            });\n    }\n}\n","import React from 'react';\nimport { Spin } from 'antd';\nimport './Loading.css';\n\nexport interface Props {\n    message: string;\n}\n\ninterface State {}\n\nexport default class Loading extends React.Component<Props, State> {\n    render() {\n        return (\n            <div className=\"Loading-box\">\n                <Spin size=\"large\" />\n                <br />\n                {this.props.message}\n            </div>\n        );\n    }\n}\n","// import { UIError } from '../types/error';\n\nexport interface DBProps<T> {\n    onUpdate: () => void;\n    initialData: T;\n}\n\nexport interface TheDB<T> {\n    data: T;\n}\n\nexport enum DBCollectionStatus {\n    NONE,\n    LOADING,\n    LOADED,\n    ERROR,\n    RELOADING\n}\n\nexport interface DBCollectionBase {\n    status: DBCollectionStatus\n}\n\nexport interface DBCollectionNone extends DBCollectionBase {\n    status: DBCollectionStatus.NONE\n}\n\nexport interface DBCollectionLoading<T> extends DBCollectionBase {\n    status: DBCollectionStatus.LOADING,\n    data: T\n}\n\nexport interface DBCollectionLoaded<T> extends DBCollectionBase {\n    status: DBCollectionStatus.LOADED,\n    data: T\n}\n\nexport interface DBCollectionReloading<T> extends DBCollectionBase {\n    status: DBCollectionStatus.RELOADING,\n    data: T\n}\n\nexport interface DBCollectionError<T> extends DBCollectionBase {\n    status: DBCollectionStatus.ERROR,\n    error: T\n}\n\nexport default class DB<T> {\n    db: TheDB<T>;\n    stopped: boolean;\n    onUpdate: () => void;\n    constructor(props: DBProps<T>) {\n        this.onUpdate = props.onUpdate;\n        this.db = {\n            data: props.initialData\n        };\n        this.stopped = false;\n    }\n\n    forceComponentUpdate() {\n        if (this.stopped) {\n            return;\n        }\n        this.onUpdate();\n    }\n\n    set(updateFun: (state: T) => T) {\n        this.db.data = updateFun(this.db.data);\n        this.forceComponentUpdate();\n    }\n\n    get(): T {\n        return this.db.data;\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n}\n","import React from 'react';\nimport { Taxon } from '../../../types/taxonomy';\nimport Wikipedia from '../../../components/Wikipedia';\n\nexport interface TaxonDescriptionProps {\n    taxon: Taxon;\n}\n\ninterface TaxonDescriptionState { }\n\nexport default class TaxonDescription extends React.Component<TaxonDescriptionProps, TaxonDescriptionState> {\n    renderTaxonDescription() {\n        return <Wikipedia term={this.props.taxon.name} />;\n    }\n\n    /**\n     * Intercept nodes which don't have a widely known biological association with\n     * the node name (\"scientific name\"), and for which a wikipedia lookup would not\n     * be very useful.\n     */\n    notBiological() {\n        switch (this.props.taxon.name) {\n            case 'root':\n                return (\n                    <div>\n                        <p>This taxon is the topmost node in the NCBI Taxonomy tree.</p>\n                    </div>\n                );\n            case 'cellular organisms':\n                return (\n                    <div>\n                        <p>This taxon represents all cellular organisms.</p>\n                    </div>\n                );\n            default:\n                return (\n                    <div>\n                        <p>Unknown non-biological taxon.</p>\n                    </div>\n                );\n        }\n    }\n\n    render() {\n        if (this.props.taxon.isBiological) {\n            return <div className=\"Col scrollable\">{this.renderTaxonDescription()}</div>;\n        }\n        return this.notBiological();\n    }\n}\n","import DB, { DBProps, DBCollectionNone, DBCollectionLoading, DBCollectionLoaded, DBCollectionReloading, DBCollectionError, DBCollectionStatus } from '../../../../lib/DB2';\nimport { AppConfig } from '@kbase/ui-components';\nimport { TaxonomyModel, LinkedObject, GetLinkedObjectsResult } from '../../lib/model';\nimport { TaxonomyReference } from '../../../../types/taxonomy';\nimport { UIError } from '../../../../types/error';\n\nexport interface LinkedObjectsData {\n    linkedObjects: Array<LinkedObject>;\n    totalCount: number;\n    page: number;\n    pageSize: number;\n}\n\nexport type LinkedObjectsStateNone = DBCollectionNone;\nexport type LinkedObjectsStateLoading = DBCollectionLoading<LinkedObjectsData>;\nexport type LinkedObjectsStateLoaded = DBCollectionLoaded<LinkedObjectsData>;\nexport type LinkedObjectsStateReloading = DBCollectionReloading<LinkedObjectsData>;\nexport type LinkedObjectsStateError = DBCollectionError<UIError>;\n\nexport type LinkedObjectsCollection =\n    LinkedObjectsStateNone |\n    LinkedObjectsStateLoading |\n    LinkedObjectsStateLoaded |\n    LinkedObjectsStateReloading |\n    LinkedObjectsStateError;\n\n// export type LinkedDataDBStateNone = DBStateNone;\n// export type LinkedDataDBStateLoading = DBStateLoading;\n// export type LinkedDataDBStateError = DBStateError;\n\n// export interface LinkedDataDBStateLoaded extends DBStateLoaded {\n//     linkedObjects: Array<LinkedObject>;\n\n// }\n\n// export type LinkedDataDBState =\n//     | LinkedDataDBStateNone\n//     | LinkedDataDBStateLoading\n//     | LinkedDataDBStateLoaded\n//     | LinkedDataDBStateError;\n\n\nexport enum SortDirection {\n    ASCENDING,\n    DESCENDING\n}\n\nexport function stringToSortDirection(direction: string) {\n    switch (direction) {\n        case 'ascending':\n            return SortDirection.ASCENDING;\n        case 'descending':\n            return SortDirection.DESCENDING;\n        default:\n            throw new Error('Unknown sort direction: ' + direction);\n    }\n}\n\nexport interface SortSpec {\n    sortColumn: string;\n    sortDirection: SortDirection;\n}\n\nexport interface LinkedObjectsDBState {\n    linkedObjectsCollection: LinkedObjectsCollection\n}\n\nexport interface LinkedDataDBProps extends DBProps<LinkedObjectsDBState> {\n    token: string;\n    config: AppConfig;\n}\n\nexport class AsyncTask<T> {\n    taskFun: () => Promise<T>;\n    hasResult: boolean;\n    result: T | null;\n    canceled: boolean;\n    constructor(taskFun: () => Promise<T>) {\n        this.taskFun = taskFun;\n        this.result = null;\n        this.hasResult = false;\n        this.canceled = false;\n    }\n\n    async run() {\n        try {\n            this.result = await this.taskFun();\n            return this.result;\n        } catch (ex) {\n            throw (ex);\n        }\n    }\n\n    cancel() {\n        this.canceled = true;\n    }\n\n    get(): T {\n        if (this.result === null) {\n            throw new Error('Attempt to fetch value when not set');\n        }\n        return this.result;\n    }\n\n    isCanceled(): boolean {\n        return this.canceled;\n    }\n}\n\nexport default class LinkedDataDB extends DB<LinkedObjectsDBState> {\n    token: string;\n    serviceWizardURL: string;\n    currentTask: AsyncTask<GetLinkedObjectsResult> | null;\n    constructor(props: LinkedDataDBProps) {\n        super(props);\n        this.token = props.token;\n        this.serviceWizardURL = props.config.services.ServiceWizard.url;\n        this.currentTask = null;\n    }\n\n    async fetchLinkedObjects({ taxonRef, page, pageSize }: { taxonRef: TaxonomyReference; page: number; pageSize: number }) {\n        if (this.currentTask) {\n            this.currentTask.cancel();\n        }\n        const task = async (): Promise<GetLinkedObjectsResult> => {\n            const client = new TaxonomyModel({\n                token: this.token,\n                url: this.serviceWizardURL\n            });\n\n            const offset = (page - 1) * pageSize;\n            const limit = pageSize;\n\n            const result = await client.getLinkedObjects(taxonRef, {\n                offset,\n                limit\n            });\n            console.log('linked', result);\n            return result;\n        };\n\n        // Set up loading based on the current state.\n\n        this.set((state: LinkedObjectsDBState) => {\n            switch (state.linkedObjectsCollection.status) {\n                case DBCollectionStatus.LOADING:\n                case DBCollectionStatus.LOADED:\n                case DBCollectionStatus.RELOADING:\n                    return {\n                        ...state,\n                        linkedObjectsCollection: {\n                            ...state.linkedObjectsCollection,\n                            status: DBCollectionStatus.LOADING\n                        }\n                    };\n                case DBCollectionStatus.NONE:\n                case DBCollectionStatus.ERROR:\n                default:\n                    return {\n                        ...state,\n                        linkedObjectsCollection: {\n                            status: DBCollectionStatus.LOADING,\n                            data: {\n                                linkedObjects: [],\n                                page, pageSize,\n                                totalCount: 0\n                            }\n                        }\n                    };\n            }\n        });\n\n        const newTask = new AsyncTask<GetLinkedObjectsResult>(task);\n        this.currentTask = newTask;\n\n        try {\n            const result = await newTask.run();\n            if (newTask.isCanceled()) {\n                return;\n            }\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    ...state,\n                    linkedObjectsCollection: {\n                        status: DBCollectionStatus.LOADED,\n                        data: {\n                            ...result,\n                            page,\n                            pageSize\n                        }\n                    }\n                };\n            });\n            this.currentTask = null;\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    ...state,\n                    linkedObjectsCollection: {\n                        status: DBCollectionStatus.ERROR,\n                        error: {\n                            code: 'not-found',\n                            message: ex.message,\n                            source: 'LinkedDataDB.fetchLinkedObjects'\n                        }\n                    }\n                };\n            });\n        }\n    }\n\n    async queryLinkedObjects({ taxonRef, page, pageSize, sort }: { taxonRef: TaxonomyReference; page: number; pageSize: number, sort: SortSpec | null }) {\n        if (this.currentTask) {\n            this.currentTask.cancel();\n        }\n        const task = async (): Promise<GetLinkedObjectsResult> => {\n            const client = new TaxonomyModel({\n                token: this.token,\n                url: this.serviceWizardURL\n            });\n\n            const offset = (page - 1) * pageSize;\n            const limit = pageSize;\n\n            const result = await client.getLinkedObjects(taxonRef, {\n                offset,\n                limit\n            });\n\n            return result;\n        };\n\n        // Set up loading based on the current state.\n\n        this.set((state: LinkedObjectsDBState) => {\n            switch (state.linkedObjectsCollection.status) {\n                case DBCollectionStatus.LOADING:\n                case DBCollectionStatus.LOADED:\n                case DBCollectionStatus.RELOADING:\n                    return {\n                        ...state,\n                        linkedObjectsCollection: {\n                            ...state.linkedObjectsCollection,\n                            status: DBCollectionStatus.LOADING\n                        }\n                    };\n                case DBCollectionStatus.NONE:\n                case DBCollectionStatus.ERROR:\n                default:\n                    return {\n                        ...state,\n                        linkedObjectsCollection: {\n                            status: DBCollectionStatus.LOADING,\n                            data: {\n                                linkedObjects: [],\n                                page, pageSize,\n                                totalCount: 0\n                            }\n                        }\n                    };\n            }\n        });\n\n        const newTask = new AsyncTask<GetLinkedObjectsResult>(task);\n        this.currentTask = newTask;\n\n        try {\n            const result = await newTask.run();\n            if (newTask.isCanceled()) {\n                return;\n            }\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    ...state,\n                    linkedObjectsCollection: {\n                        status: DBCollectionStatus.LOADED,\n                        data: {\n                            ...result,\n                            page,\n                            pageSize\n                        }\n                    }\n                };\n            });\n            this.currentTask = null;\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    ...state,\n                    linkedObjectsCollection: {\n                        status: DBCollectionStatus.ERROR,\n                        error: {\n                            code: 'not-found',\n                            message: ex.message,\n                            source: 'LinkedDataDB.fetchLinkedObjects'\n                        }\n                    }\n                };\n            });\n        }\n    }\n}\n","import React from 'react';\nimport { LinkedObject, WorkspaceType, WorkspaceObjectType } from '../../lib/model';\nimport { Table, Tooltip, Spin, Alert } from 'antd';\nimport Column from 'antd/lib/table/Column';\nimport { LinkedObjectsCollection, LinkedObjectsData } from './LinkedDataDB';\nimport { DBCollectionStatus } from '../../../../lib/DB2';\nimport { UIError } from '../../../../types/error';\nimport { SorterResult, PaginationConfig } from 'antd/lib/table';\nimport { SortSpec, stringToSortDirection } from './LinkedDataDB';\n\nconst DEFAULT_PAGE_SIZE = 12;\n\nexport interface Props {\n    linkedObjectsCollection: LinkedObjectsCollection\n    setPage: (page: number, pageSize: number) => void\n    updateView: (page: number, pageSize: number, sort: SortSpec | null) => void\n}\n\ninterface State { }\n\nexport default class LinkedData extends React.Component<Props, State> {\n    onChangePage(page: number, pageSize?: number) {\n        this.props.setPage(page, pageSize || DEFAULT_PAGE_SIZE);\n    }\n\n    onChangeTable(pagination: PaginationConfig, filters: Record<string, string[]>, sorter: SorterResult<LinkedObject>) {\n        let sort: SortSpec | null;\n        if (sorter.column && sorter.column.dataIndex) {\n            const sortColumn = sorter.column.dataIndex;\n            const sortDirection = stringToSortDirection(sorter.order === 'descend' ? 'descending' : 'ascending');\n            sort = {\n                sortColumn, sortDirection\n            };\n        } else {\n            sort = null;\n        }\n\n        this.props.updateView(pagination.current || 1, pagination.pageSize || DEFAULT_PAGE_SIZE, sort);\n    }\n\n    componentDidMount() {\n        this.props.setPage(1, DEFAULT_PAGE_SIZE);\n    }\n\n    componentDidUpdate(previousProps: Props) {\n        switch (previousProps.linkedObjectsCollection.status) {\n            case DBCollectionStatus.NONE:\n            case DBCollectionStatus.LOADING:\n            case DBCollectionStatus.LOADED:\n            case DBCollectionStatus.ERROR:\n            case DBCollectionStatus.RELOADING:\n        }\n    }\n\n    renderLinkedObjects(data: LinkedObjectsData, isLoading: boolean) {\n        return <Table<LinkedObject>\n            dataSource={data.linkedObjects}\n            size=\"small\"\n            className=\"KBaseAntdOverride-remove-table-border ScrollingFlexTable\"\n            // pagination={false}\n            // scroll={{ y: '100%' }}\n            bordered={false}\n            rowKey={(linkedObject: LinkedObject) => {\n                return [linkedObject.workspaceID, linkedObject.objectID, linkedObject.version].join('/');\n            }}\n            pagination={{\n                position: 'top',\n                // onChange: this.onChangePage.bind(this),\n                defaultPageSize: DEFAULT_PAGE_SIZE,\n                total: data.totalCount\n            }}\n            loading={isLoading}\n            onChange={this.onChangeTable.bind(this)}\n        >\n            <Column\n                title=\"Type\"\n                dataIndex=\"type\"\n                width=\"10%\"\n                render={(type: WorkspaceObjectType) => {\n                    const typeID = [[type.module, type.name].join('.'), [type.majorVersion, type.minorVersion].join('.')].join('-');\n                    return <a href={`/#spec/type/${typeID}`} target=\"_blank\" rel=\"noopener noreferrer\">\n                        {type.name}\n                    </a>\n                }}\n            />\n            <Column\n                title=\"Object\"\n                dataIndex=\"objectName\"\n                width=\"35%\"\n                // sorter={(a: LinkedObject, b: LinkedObject) => {\n                //     return a.objectName.localeCompare(b.objectName);\n                // }}\n                sorter={true}\n                render={(objectName: string, linkedObject: LinkedObject) => {\n                    const url = [\n                        '',\n                        '#dataview',\n                        linkedObject.workspaceID,\n                        linkedObject.objectID,\n                        linkedObject.version\n                    ].join('/');\n                    const headerStyle = {\n                        fontStyle: 'italic',\n                        marginRight: '3px'\n                    }\n                    const tooltip = (\n                        <div>\n                            <div>\n                                <span style={headerStyle}>\n                                    Ref\n                                </span>\n                                <span>\n                                    {linkedObject.workspaceID}/{linkedObject.objectID}/{linkedObject.version}\n                                </span>\n                            </div>\n                            <div>\n                                <span style={headerStyle}>\n                                    Workspace ID\n                                </span>\n                                <span>\n                                    {linkedObject.workspaceID}\n                                </span>\n                            </div>\n                            <div>\n                                <span style={headerStyle}>\n                                    Object ID\n                                </span>\n                                <span>\n                                    {linkedObject.objectID}\n                                </span>\n                            </div>\n                            <div>\n                                <span style={headerStyle}>\n                                    Version\n                                </span>\n                                <span>\n                                    {linkedObject.version}\n                                </span>\n                            </div>\n                        </div>\n                    )\n                    return (\n                        <Tooltip title={tooltip}>\n                            <a href={url} target=\"_blank\" rel=\"noopener noreferrer\">\n                                {objectName}\n                            </a>\n                        </Tooltip>\n                    )\n                }}\n            />\n            <Column\n                title=\"Narrative\"\n                width=\"35%\"\n                dataIndex=\"workspaceID\"\n                render={(workspaceID: number, linkedObject: LinkedObject) => {\n                    switch (linkedObject.workspaceType) {\n                        case WorkspaceType.NARRATIVE:\n                            return <a href={`/narrative/${workspaceID}`} target=\"_blank\" rel=\"noopener noreferrer\">\n                                {linkedObject.title}\n                            </a>\n                        case WorkspaceType.REFDATA:\n                            return <span>{linkedObject.title}</span>;\n                        case WorkspaceType.UNKNOWN:\n                            return <span>{linkedObject.title}</span>;\n\n                    }\n\n                }}\n            />\n            <Column\n                title=\"Object Created\"\n                dataIndex=\"createdAt\"\n                width=\"10%\"\n                // sorter={(a: LinkedObject, b: LinkedObject) => {\n                //     return a.createdAt - b.createdAt;\n                // }}\n                sorter={true}\n                render={(createdAt: number) => {\n                    return Intl.DateTimeFormat('en-US').format(createdAt);\n                }}\n            />\n            <Column\n                title=\"Linked At\"\n                dataIndex=\"linkedAt\"\n                width=\"10%\"\n                // sorter={(a: LinkedObject, b: LinkedObject) => {\n                //     return a.linkedAt - b.linkedAt;\n                // }}\n                sorter={true}\n                defaultSortOrder='descend'\n                render={(linkedAt: number) => {\n                    return Intl.DateTimeFormat('en-US').format(linkedAt);\n                }}\n            />\n        </Table>\n    }\n    renderLoading() {\n        return (\n            <Spin />\n        )\n    }\n    renderError(error: UIError) {\n        return (\n            <Alert type=\"error\" message={error.message} />\n        )\n    }\n    render() {\n        const collection = this.props.linkedObjectsCollection;\n        switch (collection.status) {\n            case DBCollectionStatus.NONE:\n                return this.renderLoading();\n            case DBCollectionStatus.ERROR:\n                return this.renderError(collection.error);\n            case DBCollectionStatus.LOADING:\n                return this.renderLinkedObjects(collection.data, true);\n            case DBCollectionStatus.LOADED:\n                return this.renderLinkedObjects(collection.data, false);\n            case DBCollectionStatus.RELOADING:\n                return this.renderLinkedObjects(collection.data, true)\n        }\n    }\n}\n","import React from 'react';\nimport { DBCollectionStatus } from '../../../../lib/DB2';\n\nimport { AppConfig } from '@kbase/ui-components';\nimport LinkedData from './view';\nimport { TaxonomyReference } from '../../../../types/taxonomy';\nimport LinkedDataDB, { SortSpec } from './LinkedDataDB';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    taxonRef: TaxonomyReference;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: LinkedDataDB;\n    lastTaxonRef: TaxonomyReference;\n    constructor(props: Props) {\n        super(props);\n        this.db = new LinkedDataDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                linkedObjectsCollection: {\n                    status: DBCollectionStatus.NONE\n                }\n            },\n            token: props.token,\n            config: props.config\n        });\n        this.lastTaxonRef = props.taxonRef;\n    }\n\n    componentDidUpdate() {\n        if (this.lastTaxonRef !== this.props.taxonRef) {\n            this.lastTaxonRef = this.props.taxonRef;\n            this.db.fetchLinkedObjects({ taxonRef: this.props.taxonRef, page: 1, pageSize: 12 })\n        }\n    }\n\n    fetchLinkedObjects(page: number, pageSize: number) {\n        return this.db.fetchLinkedObjects({ taxonRef: this.props.taxonRef, page, pageSize });\n    }\n\n    queryLinkedObjects(page: number, pageSize: number, sort: SortSpec | null) {\n        return this.db.queryLinkedObjects({ taxonRef: this.props.taxonRef, page, pageSize, sort });\n    }\n\n    // renderNone() {\n    //     return <Icon type=\"loading\" />;\n    // }\n\n    // renderLoading() {\n    //     return <Icon type=\"loading\" />;\n    // }\n\n    // renderError(db: LinkedDataDBStateError) {\n    //     return (\n    //         <ErrorView error={db.error} />\n    //     )\n    // }\n\n    // renderLoaded(db: LinkedDataDBStateLoaded) {\n    //     return <LinkedData linkedObjects={db.linkedObjects} fetchLinkedObjects={this.fetchLinkedObjects.bind(this)} />;\n    // }\n\n    // componentDidMount() {\n    //     const db = this.db.get();\n    //     switch (db.status) {\n    //         case DBStatus.NONE:\n    //             this.db.fetchLinkedObjects({ taxonRef: this.props.taxonRef, page: 1, pageSize: 1000 });\n    //     }\n    // }\n\n    // componentDidUpdate(prevProps: Props) {\n    //     if (prevProps.taxonRef.id !== this.props.taxonRef.id ||\n    //         prevProps.taxonRef.namespace !== this.props.taxonRef.namespace ||\n    //         prevProps.taxonRef.timestamp !== this.props.taxonRef.timestamp) {\n\n    //         this.db.fetchLinkedObjects({ taxonRef: this.props.taxonRef, page: 1, pageSize: 1000 });\n    //     }\n    // }\n\n    render() {\n        const db = this.db.get();\n        return <LinkedData\n            linkedObjectsCollection={db.linkedObjectsCollection}\n            updateView={this.queryLinkedObjects.bind(this)}\n            setPage={this.fetchLinkedObjects.bind(this)} />;\n        // this.renderLoaded(db);\n        // switch (db.status) {\n        //     case DBStatus.NONE:\n        //         // this.db.fetchLinkedObjects({ taxonRef: this.props.taxonRef, page: 1, pageSize: 1000 });\n        //         return this.renderNone();\n        //     case DBStatus.LOADING:\n        //         return this.renderLoading();\n        //     case DBStatus.ERROR:\n        //         return this.renderError(db);\n        //     case DBStatus.LOADED:\n        //         return this.renderLoaded(db);\n        // }\n    }\n}\n","import { AppConfig } from '@kbase/ui-components';\nimport { StoreState } from '../../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps { }\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps() {\n    return {};\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import React from 'react';\nimport { Tabs } from 'antd';\nimport TaxonDetail from './TaxonDetail';\nimport TaxonDescription from './TaxonDescription';\nimport LinkedData from './linkedData';\nimport { Taxon } from '../../../types/taxonomy';\n\nexport interface TaxonInfoProps {\n    taxon: Taxon;\n}\n\ninterface TaxonInfoState { }\n\nexport default class TaxonInfo extends React.Component<TaxonInfoProps, TaxonInfoState> {\n    render() {\n        return (\n            <Tabs defaultActiveKey=\"detail\" animated={false} className=\"FullHeight-tabs\">\n                <Tabs.TabPane tab=\"Detail\" key=\"detail\" forceRender={false}>\n                    <div className=\"Col\" style={{ overflowY: 'auto' }}>\n                        <TaxonDetail taxon={this.props.taxon} />\n                    </div>\n                </Tabs.TabPane>\n                <Tabs.TabPane tab=\"Description\" key=\"description\" forceRender={false}>\n                    <TaxonDescription taxon={this.props.taxon} />\n                </Tabs.TabPane>\n                <Tabs.TabPane tab=\"Linked Data\" key=\"linkedData\" forceRender={false}>\n                    <div className=\"Col\" style={{ overflowY: 'auto' }}>\n                        <LinkedData taxonRef={this.props.taxon.ref} />\n                    </div>\n                </Tabs.TabPane>\n            </Tabs>\n        );\n    }\n}\n","import React from 'react';\n\nimport { SourceInfo } from '../SourceInfo';\nimport LineageNavigator from '../LineageNavigator';\nimport TaxonSummary from '../TaxonSummary';\nimport { Taxon, TaxonomyReference } from '../../../types/taxonomy';\nimport { Row, Col } from 'antd';\nimport TaxonInfo from '../taxonInfo/TaxonInfo';\nimport './Taxonomy.css';\n\nexport interface TaxonomyProps {\n    // lineage: Array<Taxon>;\n    selectedTaxon: Taxon;\n    targetTaxon: Taxon;\n    selectTaxonRef: (taxonRef: TaxonomyReference) => void;\n    navigateToTaxonREf: (taxonRef: TaxonomyReference) => void;\n    setTitle: (title: string) => void;\n}\n\ninterface TaxonomyState { }\n\nexport default class Taxonomy extends React.Component<TaxonomyProps, TaxonomyState> {\n    renderTaxonInfo() {\n        if (!this.props.selectedTaxon) {\n            return <div>No taxon selected</div>;\n        }\n        return <TaxonInfo taxon={this.props.selectedTaxon} />;\n        // return 'disabled';\n    }\n\n    componentDidMount() {\n        this.props.setTitle('Taxonomy Landing Page for \"' + this.props.targetTaxon.name + '\"');\n    }\n\n    render() {\n        return (\n            <div className=\"Col scrollable Taxonomy\">\n                <div className=\"Col-auto Taxonomy-summary-section\">\n                    <Row>\n                        <Col span={12}>\n                            <TaxonSummary taxon={this.props.targetTaxon} />\n                        </Col>\n                        <Col span={12}>\n                            <SourceInfo />\n                        </Col>\n                    </Row>\n                </div>\n                <div className=\"Row scrollable\">\n                    <div className=\"Col scrollable\" style={{ flex: '0 0 20em' }}>\n                        <LineageNavigator\n                            selectedTaxon={this.props.selectedTaxon}\n                            // lineage={this.props.lineage}\n                            selectTaxonRef={this.props.selectTaxonRef}\n                            targetTaxon={this.props.targetTaxon}\n                            navigateToTaxonRef={this.props.navigateToTaxonREf}\n                        />\n                    </div>\n\n                    <div className=\"Col scrollable\" style={{ marginLeft: '10px' }}>\n                        {this.renderTaxonInfo()}\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n","import React from 'react';\nimport TaxonDB, { TaxonDBStateLoaded } from './TaxonDB';\nimport { DBStatus, DBStateError } from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport Taxonomy from './Taxonomy';\nimport { TaxonomyReference } from '../../../types/taxonomy';\nimport { Icon } from 'antd';\nimport ErrorView from '../../../components/ErrorView';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    taxonRef: TaxonomyReference;\n    // taxonID: TaxonID;\n    navigate: (taxonRef: TaxonomyReference) => void;\n    setTitle: (title: string) => void;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: TaxonDB;\n    currentlyNavigatedTaxonRef: TaxonomyReference | null;\n    constructor(props: Props) {\n        super(props);\n        this.db = new TaxonDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n        this.currentlyNavigatedTaxonRef = null;\n    }\n\n    selectTaxon(taxonRef: TaxonomyReference) {\n        return this.db.getSelectedTaxon(taxonRef);\n    }\n\n    navigateToTaxon(taxonRef: TaxonomyReference) {\n        return this.props.navigate(taxonRef);\n    }\n\n    renderLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderError(db: DBStateError) {\n        // NB this is rendered raw in the container, which is a flex row.\n        return (\n            <div className=\"Col\">\n                <div style={{ width: '50%', margin: '20px auto 0 auto' }}>\n                    <ErrorView error={db.error} />\n                </div>\n            </div>\n        );\n    }\n\n    renderLoaded(db: TaxonDBStateLoaded) {\n        return (\n            <Taxonomy\n                targetTaxon={db.targetTaxon}\n                selectedTaxon={db.selectedTaxon}\n                selectTaxonRef={this.selectTaxon.bind(this)}\n                navigateToTaxonREf={this.navigateToTaxon.bind(this)}\n                setTitle={this.props.setTitle}\n            />\n        );\n    }\n\n    componentDidMount() {\n        this.db.getTargetTaxon(this.props.taxonRef);\n    }\n\n    componentDidUpdate(previousProps: Props) {\n        if (previousProps.taxonRef.id !== this.props.taxonRef.id ||\n            previousProps.taxonRef.timestamp !== this.props.taxonRef.timestamp) {\n            this.db.getTargetTaxon(this.props.taxonRef);\n        }\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                // this.db.getTargetTaxon(this.props.taxonID);\n                return this.renderLoading();\n            case DBStatus.LOADING:\n                return this.renderLoading();\n            case DBStatus.ERROR:\n                return this.renderError(db);\n            case DBStatus.LOADED:\n                return this.renderLoaded(db);\n            // if (this.props.taxonID !== db.targetTaxon.id) {\n            //     this.db.getTargetTaxon(this.props.taxonID);\n            //     return this.renderLoaded(db);\n            // } else {\n            //     return this.renderLoaded(db);\n            // }\n        }\n    }\n}\n","import { AppConfig, sendTitle } from '@kbase/ui-components';\nimport { StoreState } from '../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { navigate } from '../../../redux/actions';\nimport { TaxonomyReference } from '../../../types/taxonomy';\nimport { relationEngineReferenceToNamespace } from '../../../types/transform';\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps {\n    navigate: (ref: TaxonomyReference) => void;\n    setTitle: (title: string) => void;\n}\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, props: OwnProps): DispatchProps {\n    return {\n        navigate: (ref: TaxonomyReference) => {\n            const relationEngineID = [\n                relationEngineReferenceToNamespace(ref),\n                ref.id,\n                String(ref.timestamp)\n            ].join('/');\n            dispatch(navigate(relationEngineID) as any);\n        },\n        setTitle: (title: string) => {\n            dispatch(sendTitle(title) as any);\n        }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import { RelationEngineID, StoreState } from '../../redux/store';\n// import { TaxonID } from './redux/store';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { navigate } from '../../redux/actions';\nimport { connect } from 'react-redux';\nimport Taxonomy from './main';\nimport { sendTitle } from '@kbase/ui-components';\n\nexport interface OwnProps {\n    // taxonID: TaxonID;\n}\n\nexport interface StateProps {\n    // taxonID: TaxonID;\n}\n\nexport interface DispatchProps {\n    navigate: (relationEngineID: RelationEngineID) => void;\n    setTitle: (title: string) => void;\n    // load: (taxonID: TaxonID) => void;\n}\n\nfunction mapStateToProps(state: StoreState, ownProps: OwnProps): StateProps {\n    return {};\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, ownProps: OwnProps): DispatchProps {\n    return {\n        navigate: (relationEngineId: RelationEngineID) => {\n            dispatch(navigate(relationEngineId) as any);\n        },\n        setTitle: (title: string) => {\n            dispatch(sendTitle(title) as any);\n        }\n        // load: (taxonID: TaxonID) => {\n        //     dispatch(load(taxonID) as any);\n        // }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(Taxonomy);\n","import { RelationEngineDataSource, RelationEngineCategory, RelationEngineReferenceG } from \"./core\";\n\n// Ontology Term Reference\n\n// export enum OntologyNamespace {\n//     GO\n// }\n\nexport function stringToOntologyNamespace(namespace: string): OntologyNamespace {\n    switch (namespace) {\n        case 'go_ontology':\n            return 'go_ontology';\n        case 'envo_ontology':\n            return 'envo_ontology';\n        default:\n            throw new Error('Ontology namespace not supported: ' + namespace);\n    }\n}\n\nexport function ontologyNamespaceToString(namespace: OntologyNamespace): string {\n    switch (namespace) {\n        case 'go_ontology':\n            return 'go_ontology';\n        case 'envo_ontology':\n                return 'envo_ontology';\n    }\n}\n\n\n// export interface OntologyReferenceBase extends RelationEngineReferenceBase {\n//     category: RelationEngineCategory.ONTOLOGY;\n// }\n\n// export interface OntologyReferenceGO extends OntologyReferenceBase {\n//     dataSource: RelationEngineDataSource.GO;\n// }\n\n// export interface OntologyReferenceENVO extends OntologyReferenceBase {\n//     dataSource: RelationEngineDataSource.ENVO;\n// }\n\n// export type OntologyReference = OntologyReferenceGO | OntologyReferenceENVO\n\nexport type OntologyNamespace =\n    'envo_ontology' |\n    'go_ontology';\n\nexport type OntologyReference =\n    RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.GO> |\n    RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.ENVO>;\n\n\n// export type OntologyID = string;\n\nexport enum OntologySource {\n    GO\n}\nexport enum OntologyRelation {\n    IS_A = 'OntologyRelation$is_a',\n    PART_OF = 'OntologyRelation$part_of',\n    HAS_PART = 'OntologyRelation$has_part',\n    REGULATES = 'OntologyRelation$regulates',\n    POSITIVELY_REGULATES = 'OntologyRelation$positivelyRegulates',\n    NEGATIVELY_REGULATES = 'OntologyRelation$negativelyRegulates',\n    OCCURS_IN = 'OntologyRelation$occursIn',\n    ENDS_DURING = 'OntologyRelation$endsDuring',\n    HAPPENS_DURING = 'OntologyRelation$happensDuring'\n}\n\n// Brief term - for list displays\n\nexport interface OntologyTermBriefBase {\n    ref: OntologyReference;\n    name: string;\n}\n\nexport interface GOOntologyTermBrief extends OntologyTermBriefBase {\n    ref: RelationEngineReferenceG<RelationEngineCategory.ONTOLOGY, RelationEngineDataSource.GO>\n    goID: string;\n}\n\nexport type OntologyTermBrief = GOOntologyTermBrief;\n\nexport type OntologyRelatedTermBrief = {\n    relation: OntologyRelation,\n    term: OntologyTermBrief\n}\n\nexport interface OntologyTermRelatedBrief extends OntologyTermBrief {\n    relation: OntologyRelation\n}\n\n// Term - the full term info for detail\n\nexport interface OntologyTermBase {\n    ref: OntologyReference;\n    name: string;\n    comments: Array<string>\n    definition: string;\n    isObsolete: boolean;\n}\n\nexport enum GOSynonymScope {\n    EXACT,\n    NARROW,\n    BROAD,\n    RELATED\n}\n\nexport type Synonym = string;\n\nexport interface GOSynonyms {\n    exact: Array<Synonym>;\n    narrow: Array<Synonym>;\n    broad: Array<Synonym>;\n    related: Array<Synonym>;\n}\n\nexport interface GOOntologyTerm extends OntologyTermBase {\n    type: OntologySource.GO;\n    synonyms: GOSynonyms;\n    goID: string;\n    namespace: string;\n}\n\nexport type OntologyTerm = GOOntologyTerm;\n\nexport interface OntologyTermRelated extends OntologyTerm {\n    related: OntologyRelation\n}\n\nexport interface OntologyRelatedTerm {\n    relation: OntologyRelation,\n    term: OntologyTerm\n}\n\nexport interface OntologyRelatedTerms {\n    term: OntologyTerm,\n    terms: Array<OntologyRelatedTerm>\n}\n\n/* Linked Objects */\n\nexport interface WorkspaceType {\n    module: string;\n    name: string;\n}\nexport type WorkspaceID = number;\nexport type ObjectID = number;\nexport type ObjectVersion = number;\nexport interface WorkspaceObjectReference {\n    workspaceID: WorkspaceID;\n    id: ObjectID;\n    version: ObjectVersion;\n}\n\nexport interface LinkedObject {\n    object: WorkspaceObjectReference;\n    type: WorkspaceType,\n    scientificName: string;\n    feature: string;\n}","import { DynamicServiceClient } from \"@kbase/ui-lib\";\nimport { RelationEngineNamespace } from \"../../../types/core\";\n\nexport interface GetParentsParams {\n    ns: Namespace;\n    id: string;\n    ts: number;\n}\n\n// TODO: this should not live here, or should just be a string?\nexport type Namespace = 'go_ontology' | 'envo_ontology';\n\nexport interface GetParentsResult {\n    results: Array<RelatedTerm>;\n    ns: Namespace;\n    ts: number;\n}\n\nexport interface GetChildrenParams {\n    ns: Namespace;\n    id: string;\n    ts: number;\n}\n\nexport interface GetChildrenResult {\n    results: Array<RelatedTerm>;\n    ns: Namespace;\n    ts: number;\n}\n\nexport interface Synonym {\n    pred: string;\n    val: string;\n    xrefs: Array<XRef>\n}\n\nexport interface XRef {\n    val: string;\n}\n\n// export interface Termx {\n//     ns: string;\n//     id: string;\n//     ts: number;\n//     name: string;\n//     scientific_name: string;\n//     relation: string;\n//     synonyms: Array<Synonym>;\n//     goID?: string;\n//     commnent: string;\n//     definition: string;\n// }\n\n// doesn't include the underscore fields\n// TODO: the api should not return any underscore\n// fields.\nexport interface TermNode {\n    namespace: string;\n    id: string;\n    alt_ids: Array<string>;\n    name: string;\n    comments: Array<string>;\n    def: {\n        val: string;\n        xrefs: Array<XRef>;\n    };\n    created: number;\n    expired: number;\n    subsets: Array<string>;\n    synonyms: Array<Synonym>;\n    type: string;\n    xrefs: Array<XRef>;\n\n    first_version: string;\n    last_version: string;\n    release_created: number;\n    release_expired: number;\n}\n\n// aka relation\n/*\n case 'is_a':\n            return OntologyRelation.IS_A;\n        case 'part_of':\n            return OntologyRelation.PART_OF;\n        case 'has_part':\n            return OntologyRelation.HAS_PART;\n        case 'regulates':\n            return OntologyRelation.REGULATES;\n        case 'positively_regulates':\n            return OntologyRelation.POSITIVELY_REGULATES;\n        case 'negatively_regulates':\n            return OntologyRelation.NEGATIVELY_REGULATES;\n        case 'occurs_in':\n            return OntologyRelation.OCCURS_IN;\n        case 'ends_during':\n            return OntologyRelation.ENDS_DURING;\n        case 'happens_during':\n            return OntologyRelation.HAPPENS_DURING;\n*/\nexport type EdgeType = 'is_a' | 'part_of' | 'has_part' | 'regulates' | 'positively_regulates' |\n    'negatively_regulates' | 'occurs_in' | 'ends_during' | 'happens_during';\n\nexport interface TermEdge {\n    id: string;\n    type: EdgeType;\n    created: number;\n    expired: number;\n    first_version: string;\n    last_version: string;\n    from: string;\n    to: string;\n    release_created: number;\n    release_expired: number;\n}\n\nexport interface RelatedTerm {\n    term: TermNode;\n    edge: TermEdge;\n}\n\n// export interface TermBrief {\n//     ns: Namespace;\n//     id: string;\n//     ts: number;\n//     name: string;\n//     scientific_name: string;\n//     relation: string;\n// }\n\nexport type TermBrief = TermNode;\n\nexport interface GetTermsParams {\n    ids: Array<string>;\n    ts: number;\n    ns: Namespace;\n}\n\nexport interface GetTermsResult {\n    results: Array<TermNode>;\n    ts: number;\n    ns: string;\n    // ignore the stats\n}\n\nexport interface GetRelatedObjectsParams {\n    ns: RelationEngineNamespace;\n    id: string;\n    ts: number;\n}\n\nexport interface GetRelatedObjectsResult {\n\n}\n\nexport interface GetHierarchicalAncestorsParams {\n    ns: Namespace;\n    id: string;\n    ts: number;\n    offset: number;\n    limit: number;\n}\n\nexport interface GetHierarchicalAncestorsResult {\n    results: Array<RelatedTerm>;\n    ns: Namespace;\n    ts: number;\n}\n\nexport interface GetAssociatedWSObjectsParams {\n    id: string,\n    ns: Namespace,\n    ts: number,\n    offset: number,\n    limit: number\n}\n\nexport interface RelatedWSObject {\n    features: Array<{\n        feature_id: string;\n        updated_at: number;\n    }>,\n    ws_obj: {\n        name: string,\n        workspace_id: number;\n        object_id: number;\n        version: number;\n    }\n}\n\nexport interface GetAssociatedWSObjectsResults {\n    results: Array<RelatedWSObject>;\n    ns: string;\n    ts: number;\n    stats: any;\n}\n\nexport default class OntologyAPIClient extends DynamicServiceClient {\n    static module: string = 'OntologyAPI';\n\n    async getParents(params: GetParentsParams): Promise<GetParentsResult> {\n        const [result] = await this.callFunc<[GetParentsParams], [GetParentsResult]>('get_parents', [\n            params\n        ]);\n        return result;\n    }\n\n    async getTerms(params: GetTermsParams): Promise<GetTermsResult> {\n        const [result] = await this.callFunc<[GetTermsParams], [GetTermsResult]>('get_terms', [\n            params\n        ]);\n        return result;\n    }\n\n    async getChildren(params: GetChildrenParams): Promise<GetChildrenResult> {\n        const [result] = await this.callFunc<[GetChildrenParams], [GetChildrenResult]>('get_children', [\n            params\n        ]);\n        return result;\n    }\n\n    async getRelatedObjects(params: GetRelatedObjectsParams): Promise<GetRelatedObjectsResult> {\n        const [result] = await this.callFunc<[GetRelatedObjectsParams], [GetRelatedObjectsResult]>('get_children', [\n            params\n        ]);\n        return result;\n    }\n\n    async getHierarchicalAncestors(params: GetHierarchicalAncestorsParams): Promise<GetHierarchicalAncestorsResult> {\n        const [result] = await this.callFunc<[GetHierarchicalAncestorsParams], [GetHierarchicalAncestorsResult]>('get_hierarchical_ancestors', [\n            params\n        ]);\n        return result;\n    }\n\n    async getAssociatedWSObjects(params: GetAssociatedWSObjectsParams): Promise<GetAssociatedWSObjectsResults> {\n        const [result] = await this.callFunc<[GetAssociatedWSObjectsParams], [GetAssociatedWSObjectsResults]>('get_associated_ws_objects', [\n            params\n        ]);\n        return result;\n    }\n}","import OntologyAPIClient, {  TermNode, RelatedTerm, EdgeType } from './OntologyAPIClient';\nimport { OntologyReference, OntologyNamespace, OntologyTerm, OntologySource, GOOntologyTerm, OntologyRelatedTerm, OntologyRelation, stringToOntologyNamespace } from '../../../types/ontology';\nimport { RelationEngineCategory, RelationEngineDataSource } from '../../../types/core';\n\nexport interface GetTermParams {\n    ref: OntologyReference\n}\n\nexport interface GetTermResult {\n    term: OntologyTerm;\n}\n\nexport interface GetTermsParams {\n    refs: Array<OntologyReference>\n}\n\nexport interface GetTermsResult {\n    terms: Array<OntologyTerm>;\n}\n\nexport interface GetParentsParams {\n    ref: OntologyReference;\n}\n\n// TODO: this should be a \"related term\", although maybe the relation \n// collapses out with ontology - are they all is_a at least for parents, children?\nexport interface GetParentsResult {\n    terms: Array<OntologyRelatedTerm>\n}\n\nexport interface GetChildrenParams {\n    ref: OntologyReference;\n}\n\n// TODO: this should be a \"related term\", although maybe the relation \n// collapses out with ontology - are they all is_a at least for parents, children?\nexport interface GetChildrenResult {\n    terms: Array<OntologyRelatedTerm>\n}\n\nexport interface GetAncestorGraphParams {\n    ref: OntologyReference;\n}\n\nexport interface GetRelatedFeaturesParams {\n    ref: OntologyReference;\n    offset: number;\n    limit: number;\n}\n\nexport interface WorkspaceObjectReference {\n    workspaceID: number;\n    objectID: number;\n    version: number;\n}\n\nexport interface RelatedFeature {\n    objectName: string;\n    featureID: string;\n    relatedAt: number;\n    objectRef: WorkspaceObjectReference;\n}\n\nexport interface GetRelatedFeaturesResult {\n    features: Array<RelatedFeature>\n}\n\nexport type NodeID = string;\n\nexport interface TermsGraphNode {\n    term: OntologyTerm;\n    isRoot: boolean;\n    id: NodeID;\n}\n\nexport interface TermsGraphRelation {\n    relation: OntologyRelation;\n    from: NodeID;\n    to: NodeID;\n}\n\nexport interface TermsGraph {\n    terms: Array<TermsGraphNode>;\n    relations: Array<TermsGraphRelation>;\n}\n\nexport interface GetAncestorGraphResult {\n    termsGraph: TermsGraph;\n}\n\nexport function termNodeToTerm(term: TermNode, ts: number): OntologyTerm {\n    const namespace = stringToOntologyNamespace('go_ontology');\n    switch (namespace) {\n        case 'go_ontology':\n            const temp: GOOntologyTerm = {\n                type: OntologySource.GO,\n                ref: {\n                    category: RelationEngineCategory.ONTOLOGY,\n                    dataSource: RelationEngineDataSource.GO, // TODO: stringToOntologyNamespace(term.ns),\n                    id: term.id,\n                    timestamp: ts\n                },\n                namespace: term.namespace,\n                comments: term.comments,\n                definition: term.def.val,\n                goID: term.id,\n                isObsolete: false, // ignored for now, \n                name: term.name,\n                synonyms: {\n                    exact: term.synonyms.filter((synonym) => {\n                        return synonym.pred === 'hasExactSynonym'\n                    }).map((synonym) => {\n                        return synonym.val;\n                    }),\n                    narrow: term.synonyms.filter((synonym) => {\n                        return synonym.pred === 'hasNarrowSynonym'\n                    }).map((synonym) => {\n                        return synonym.val;\n                    }),\n                    broad: term.synonyms.filter((synonym) => {\n                        return synonym.pred === 'hasBroadSynonym'\n                    }).map((synonym) => {\n                        return synonym.val;\n                    }),\n                    related: term.synonyms.filter((synonym) => {\n                        return synonym.pred === 'hasRelatedSynonym'\n                    }).map((synonym) => {\n                        return synonym.val;\n                    }),\n                }, // TODO:\n            };\n            return temp;\n        default:\n            throw new Error('Ontology namespace not yet supported: ' + namespace);\n    }\n}\n\n/*\n  IS_A = 'OntologyRelation$is_a',\n    PART_OF = 'OntologyRelation$part_of',\n    HAS_PART = 'OntologyRelation$has_part',\n    REGULATES = 'OntologyRelation$regulates',\n    POSITIVELY_REGULATES = 'OntologyRelation$positivelyRegulates',\n    NEGATIVELY_REGULATES = 'OntologyRelation$negativelyRegulates',\n    OCCURS_IN = 'OntologyRelation$occursIn',\n    ENDS_DURING = 'OntologyRelation$endsDuring',\n    HAPPENS_DURING = 'OntologyRelation$happensDuring'\n*/\n\nexport function stringToTermRelation(relationString: EdgeType): OntologyRelation {\n    switch (relationString) {\n        case 'is_a':\n            return OntologyRelation.IS_A;\n        case 'part_of':\n            return OntologyRelation.PART_OF;\n        case 'has_part':\n            return OntologyRelation.HAS_PART;\n        case 'regulates':\n            return OntologyRelation.REGULATES;\n        case 'positively_regulates':\n            return OntologyRelation.POSITIVELY_REGULATES;\n        case 'negatively_regulates':\n            return OntologyRelation.NEGATIVELY_REGULATES;\n        case 'occurs_in':\n            return OntologyRelation.OCCURS_IN;\n        case 'ends_during':\n            return OntologyRelation.ENDS_DURING;\n        case 'happens_during':\n            return OntologyRelation.HAPPENS_DURING;\n        default:\n            throw new Error('Unknown relation: ' + relationString);\n    }\n}\n\nexport function relationToString(relation: OntologyRelation): EdgeType {\n    switch (relation) {\n        case OntologyRelation.IS_A:\n            return 'is_a';\n        case OntologyRelation.PART_OF:\n            return 'part_of';\n        case OntologyRelation.HAS_PART:\n            return 'has_part';\n        case OntologyRelation.REGULATES:\n            return 'regulates';\n        case OntologyRelation.POSITIVELY_REGULATES:\n            return 'positively_regulates';\n        case OntologyRelation.NEGATIVELY_REGULATES:\n            return 'negatively_regulates';\n        case OntologyRelation.OCCURS_IN:\n            return 'occurs_in';\n        case OntologyRelation.ENDS_DURING:\n            return 'ends_during';\n        case OntologyRelation.HAPPENS_DURING:\n            return 'happens_during';\n    }\n}\n\nexport function relatedTermToTerm(relatedTerm: RelatedTerm, ts: number): OntologyRelatedTerm {\n    const term = termNodeToTerm(relatedTerm.term, ts);\n    const relation = stringToTermRelation(relatedTerm.edge.type)\n    return {\n        term, relation\n    }\n}\n\nexport function ontologyReferenceToNamespace(ref: OntologyReference): OntologyNamespace {\n    switch (ref.category) {\n        case RelationEngineCategory.ONTOLOGY:\n            switch (ref.dataSource) {\n                case RelationEngineDataSource.GO:\n                    return 'go_ontology';\n                case RelationEngineDataSource.ENVO:\n                    return 'envo_ontology';\n            }\n    }\n}\n\nexport default class OntologyModel {\n    ontologyClient: OntologyAPIClient;\n    token: string;\n    url: string;\n    constructor({ token, url }: { token: string; url: string }) {\n        this.token = token;\n        this.url = url;\n        this.ontologyClient = new OntologyAPIClient({ token, url });\n    }\n\n    // async getTerms({ refs }: GetTermsParams): Promise<GetTermsResult> {\n    //     const client = new OntologyAPIClient({\n    //         token: this.token,\n    //         url: this.url\n    //     });\n\n    //     if (refs.length === 0) {\n    //         return { terms: [] };\n    //     }\n\n    //     const ns = ontologyNamespaceToString(refs[0].namespace);\n    //     const ids = refs.map(({ id }))\n\n    //     const result = await client.getTerms({\n    //         ns,\n    //         ids: [ref.id],\n    //         ts: ref.timestamp\n    //     })\n\n    //     return {\n    //         term: rawTermToTerm(result.term, result.ts)\n    //     };\n\n    // }\n\n    async getTerm({ ref }: {ref: OntologyReference}): Promise<GetTermResult> {\n        const client = new OntologyAPIClient({\n            token: this.token,\n            url: this.url\n        });\n\n        const result = await client.getTerms({\n            ns: ontologyReferenceToNamespace(ref),\n            ids: [ref.id],\n            ts: ref.timestamp || Date.now()\n        });\n\n        return {\n            term: termNodeToTerm(result.results[0], result.ts)\n        };\n    }\n\n    async getParents({ ref }: GetParentsParams): Promise<GetParentsResult> {\n        const client = new OntologyAPIClient({\n            token: this.token,\n            url: this.url\n        });\n\n        const result = await client.getParents({\n            ns: ontologyReferenceToNamespace(ref),\n            id: ref.id,\n            ts: ref.timestamp || Date.now()\n        });\n\n        return {\n            terms: result.results.map((item) => {\n                return relatedTermToTerm(item, result.ts);\n            })\n        };\n    }\n\n    async getChildren({ ref }: GetChildrenParams): Promise<GetChildrenResult> {\n        const client = new OntologyAPIClient({\n            token: this.token,\n            url: this.url\n        });\n\n        const result = await client.getChildren({\n            ns: ontologyReferenceToNamespace(ref),\n            id: ref.id,\n            ts: ref.timestamp || Date.now()\n        });\n\n        return {\n            terms: result.results.map((item) => {\n                return relatedTermToTerm(item, result.ts);\n            })\n        };\n    }\n\n    async getRelatedFeatures({ ref, offset, limit }: GetRelatedFeaturesParams): Promise<GetRelatedFeaturesResult> {\n        const client = new OntologyAPIClient({\n            token: this.token,\n            url: this.url\n        });\n\n        const result = await client.getAssociatedWSObjects({\n            ns: ontologyReferenceToNamespace(ref),\n            id: ref.id,\n            ts: ref.timestamp || Date.now(),\n            offset, limit\n        })\n\n        // const features: Array<RelatedFeature> = result.results.reduce((features, genomeWithFeatures) => {\n        //     genomeWithFeatures.features.forEach((feature) => {\n        //         features.push({\n        //             featureID: feature.feature_id,\n        //             relatedAt: feature.updated_at,\n        //             objectName: genomeWithFeatures.ws_obj.name,\n        //             objectRef: {\n        //                 workspaceID: genomeWithFeatures.ws_obj.workspace_id,\n        //                 objectID: genomeWithFeatures.ws_obj.object_id,\n        //                 version: genomeWithFeatures.ws_obj.version\n        //             }\n        //         });\n        //     })\n        //     return features;\n        // }, []: Array<RelatedFeature>);\n\n\n        const features: Array<RelatedFeature> = []\n        result.results.forEach((genomeWithFeatures) => {\n            genomeWithFeatures.features.forEach((feature) => {\n                features.push({\n                    featureID: feature.feature_id,\n                    relatedAt: feature.updated_at,\n                    objectName: genomeWithFeatures.ws_obj.name,\n                    objectRef: {\n                        workspaceID: genomeWithFeatures.ws_obj.workspace_id,\n                        objectID: genomeWithFeatures.ws_obj.object_id,\n                        version: genomeWithFeatures.ws_obj.version\n                    }\n                });\n            })\n        });\n\n        return {\n            features\n        }\n    }\n\n    async getAncestorGraph({ ref }: GetAncestorGraphParams): Promise<GetAncestorGraphResult> {\n        const client = new OntologyAPIClient({\n            token: this.token,\n            url: this.url\n        });\n\n        const result = await client.getHierarchicalAncestors({\n            ns: ontologyReferenceToNamespace(ref),\n            id: ref.id,\n            ts: ref.timestamp || Date.now(),\n            // TODO: should these be params? We can't support paging for the ancestor graph,\n            // and it should never be too large, so probably remove from the upstream api??\n            offset: 0,\n            limit: 1000\n        });\n\n        const relations: Array<TermsGraphRelation> = [];\n        result.results.forEach((item) => {\n            const relation = stringToTermRelation(item.edge.type);\n            // if (item.edge.from === 'GO:0008150' || item.edge.to === 'GO:0008150') {\n            //     console.log('R', item.edge.from === item.edge.to, item.edge.from, item.edge.to);\n            // }\n            // if (item.term.id === 'GO:0008150') {\n            //     console.log('T', item);\n            // }\n            if (relations.some((r) => {\n                return r.from === item.edge.from &&\n                    r.to === item.edge.to &&\n                    r.relation === relation\n            })) {\n                return;\n            }\n            relations.push({\n                relation,\n                from: item.edge.from,\n                to: item.edge.to\n            });\n        });\n        const relationsMap = relations.reduce((m, r) => {\n            let nodes = m.get(r.from);\n            if (!nodes) {\n                nodes = [];\n            }\n            nodes.push(r);\n            m.set(r.from, nodes);\n            return m;\n        }, new Map<string, Array<TermsGraphRelation>>());\n\n        const terms = new Map<string, TermsGraphNode>();\n        result.results.forEach((item) => {\n            if (!terms.has(item.term.id)) {\n                const term = termNodeToTerm(item.term, result.ts);\n                let isRoot = false;\n                const nodes = relationsMap.get(term.ref.id);\n                if (!nodes) {\n                    isRoot = true;\n                }\n\n                terms.set(item.term.id, {\n                    id: term.ref.id,\n                    term, isRoot\n                });\n            }\n        });\n\n        return {\n            termsGraph: {\n                terms: Array.from(terms.values()),\n                relations\n            }\n        };\n    }\n}","import DB, { DBProps, DBStatus, DBStateNone, DBStateLoading, DBStateLoaded, DBStateError } from '../../../lib/DB';\nimport { OntologyTerm, OntologyReference } from '../../../types/ontology';\nimport { AppConfig } from '@kbase/ui-components';\nimport OntologyModel from '../lib/model';\n\nexport type OntologyDBStateNone = DBStateNone;\nexport type OntologyDBStateLoading = DBStateLoading;\nexport type OntologyDBStateError = DBStateError;\nexport interface OntologyDBStateLoaded extends DBStateLoaded {\n    targetTerm: OntologyTerm;\n    selectedTerm: OntologyTerm;\n}\n\nexport type OntologyDBState = OntologyDBStateNone | OntologyDBStateLoading | OntologyDBStateLoaded | OntologyDBStateError;\n\nexport interface OntologyDBProps extends DBProps<OntologyDBState> {\n    token: string;\n    config: AppConfig;\n}\n\nexport default class OntologyDB extends DB<OntologyDBState> {\n    props: OntologyDBProps;\n    constructor(props: OntologyDBProps) {\n        super(props);\n        this.props = props;\n    }\n\n    async getTargetTerm(termRef: OntologyReference) {\n        this.set((state: OntologyDBState) => {\n            return {\n                ...state,\n                status: DBStatus.LOADING\n            };\n        });\n\n        const client = new OntologyModel({\n            token: this.props.token,\n            url: this.props.config.services.ServiceWizard.url\n        });\n\n        try {\n\n            const { term } = await client.getTerm({\n                ref: termRef\n            });\n\n            this.set((state: OntologyDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    targetTerm: term,\n                    selectedTerm: term\n                }\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: OntologyDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.ERROR,\n                    error: ex.message\n                };\n            });\n        }\n    }\n\n    async setSelectedTerm(termRef: OntologyReference) {\n        const state = this.get();\n\n        if (state.status !== DBStatus.LOADED) {\n            return;\n        }\n\n        const client = new OntologyModel({\n            token: this.props.token,\n            url: this.props.config.services.ServiceWizard.url\n        });\n\n        const { term } = await client.getTerm({ ref: termRef })\n\n        this.set((state: OntologyDBState) => {\n            return {\n                ...state,\n                selectedTerm: term\n            };\n        });\n    }\n}","import React from 'react';\nimport { OntologySource, GOOntologyTerm, OntologyTerm } from '../../types/ontology';\nimport { Icon, Tooltip } from 'antd';\n\nexport interface Props {\n    term: OntologyTerm;\n    newWindow: boolean;\n}\n\ninterface State {\n}\n\nexport default class TermLink extends React.Component<Props, State> {\n    renderGOLink(term: GOOntologyTerm) {\n        const href = `http://amigo.geneontology.org/amigo/term/${term.goID}`;\n        const target = this.props.newWindow ? '_blank' : '_parent';\n        const tooltip = (\n            <React.Fragment>\n                <p>Link to the Gene Ontology AmiGO page for this term.</p>\n                <p>Opens in a separate window or tab.</p>\n            </React.Fragment>\n        )\n        return (\n            <Tooltip title={tooltip}>\n                <a href={href} target={target}>\n                    {term.ref.id} <Icon type=\"link\" />\n                </a>\n            </Tooltip>\n        )\n    }\n\n    render() {\n        const term = this.props.term;\n        switch (term.type) {\n            case (OntologySource.GO):\n                return this.renderGOLink(term);\n        }\n    }\n}","import DB, { DBProps, DBStatus, DBStateNone, DBStateLoading, DBStateLoaded, DBStateError } from '../../../../lib/DB';\nimport { OntologyReference } from '../../../../types/ontology';\nimport { AppConfig } from '@kbase/ui-components';\nimport OntologyModel, { RelatedFeature } from '../../lib/model';\n\nexport type LinkedObjectsDBStateNone = DBStateNone;\nexport type LinkedObjectsDBStateLoading = DBStateLoading;\nexport type LinkedObjectsDBStateError = DBStateError;\n\nexport interface LinkedObjectsDBStateLoaded extends DBStateLoaded {\n    linkedObjects: Array<RelatedFeature>\n}\n\nexport type LinkedObjectsDBState = LinkedObjectsDBStateNone | LinkedObjectsDBStateLoading | LinkedObjectsDBStateError | LinkedObjectsDBStateLoaded;\n\nexport interface LinkedObjectsProps extends DBProps<LinkedObjectsDBState> {\n    token: string;\n    config: AppConfig;\n}\n\nexport default class LinkedObjectsDB extends DB<LinkedObjectsDBState> {\n    props: LinkedObjectsProps;\n    constructor(props: LinkedObjectsProps) {\n        super(props);\n        this.props = props;\n\n    }\n    async getLinkedObjects(termRef: OntologyReference) {\n        const client = new OntologyModel({\n            url: this.props.config.services.ServiceWizard.url,\n            token: this.props.token\n        });\n        try {\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADING\n                }\n            });\n\n            const linkedObjects = await client.getRelatedFeatures({\n                ref: termRef,\n                // TODO: provided by table ui\n                offset: 0,\n                limit: 1000\n            })\n\n            // do the call here when it is available\n\n            // const linkedObjects: Array<LinkedObject> = [\n            //     {\n            //         object: {\n            //             workspaceID: 43747,\n            //             id: 4,\n            //             version: 1\n            //         },\n            //         type: {\n            //             module: 'KBaseGenomes',\n            //             name: 'Genome'\n            //         },\n            //         scientificName: 'Escherichia coli',\n            //         feature: 'CF61_RS00005a'\n            //     },\n            //     {\n            //         object: {\n            //             workspaceID: 43747,\n            //             id: 4,\n            //             version: 1\n            //         },\n            //         type: {\n            //             module: 'KBaseGenomes',\n            //             name: 'Genome'\n            //         },\n            //         scientificName: 'Escherichia coli',\n            //         feature: 'CF61_RS00005b'\n            //     },\n            //     {\n            //         object: {\n            //             workspaceID: 43747,\n            //             id: 4,\n            //             version: 1\n            //         },\n            //         type: {\n            //             module: 'KBaseGenomes',\n            //             name: 'Genome'\n            //         },\n            //         scientificName: 'Escherichia coli',\n            //         feature: 'CF61_RS00005c'\n            //     },\n            //     {\n            //         object: {\n            //             workspaceID: 43747,\n            //             id: 4,\n            //             version: 1\n            //         },\n            //         type: {\n            //             module: 'KBaseGenomes',\n            //             name: 'Genome'\n            //         },\n            //         scientificName: 'Escherichia coli',\n            //         feature: 'CF61_RS00005d'\n            //     }\n            // ]\n\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    linkedObjects: linkedObjects.features\n                }\n            });\n        } catch (ex) {\n            this.set((state: LinkedObjectsDBState) => {\n                return {\n                    status: DBStatus.ERROR,\n                    error: {\n                        code: 'not-found',\n                        source: 'LinkedObjectsDB.getLinkedObjects',\n                        message: ex.message\n                    }\n                }\n            });\n        }\n    }\n\n}\n","import React from 'react';\nimport './style.css';\nimport { Table } from 'antd';\nimport { RelatedFeature } from '../../lib/model';\n\nexport interface Props {\n    linkedObjects: Array<RelatedFeature>;\n}\n\ninterface State {\n}\n\nexport default class LinkedObjects extends React.Component<Props, State> {\n    renderTable() {\n        return <Table<RelatedFeature>\n            dataSource={this.props.linkedObjects}\n            className=\"KBaseAntdOverride-remove-table-border ScrollingFlexTable\"\n            size=\"small\"\n            pagination={false}\n            scroll={{ y: '100%' }}\n            rowKey={(row: RelatedFeature) => {\n                return [\n                    row.objectRef.workspaceID,\n                    row.objectRef.objectID,\n                    row.objectRef.version,\n                    row.featureID\n                ].join(':');\n            }}\n            bordered={false}\n        >\n            <Table.Column\n                dataIndex={\"objectName\"}\n                title=\"Object Name\"\n                width=\"40%\"\n                render={(objectName: string, row: RelatedFeature) => {\n                    const hash = [\n                        'dataview',\n                        String(row.objectRef.workspaceID),\n                        String(row.objectRef.objectID),\n                        String(row.objectRef.version)\n                    ].join('/');\n                    const url = new URL('', window.location.origin);\n                    url.hash = hash;\n                    return (\n                        <a href={url.toString()} target=\"_blank\" rel=\"noopener noreferrer\">\n                            {objectName}\n                        </a>\n                    )\n                }}\n            />\n            <Table.Column\n                dataIndex={\"featureID\"}\n                title=\"Feature\"\n                width=\"40%\"\n                render={(featureID: string, row: RelatedFeature) => {\n                    const hash = [\n                        'dataview',\n                        String(row.objectRef.workspaceID),\n                        String(row.objectRef.objectID),\n                        String(row.objectRef.version)\n                    ].join('/');\n                    // Note the sample url just to make URL happy.\n                    const url = new URL('', window.location.origin);\n                    url.hash = hash;\n                    const search = url.searchParams;\n                    search.set('sub', 'Feature');\n                    search.set('subid', featureID);\n                    return (\n                        <a href={url.toString()} target=\"_blank\" rel=\"noopener noreferrer\">\n                            {featureID}\n                        </a>\n                    )\n                }}\n            />\n            <Table.Column\n                dataIndex={\"relatedAt\"}\n                width=\"20%\"\n                title=\"Linked\"\n                render={(relatedAt: number) => {\n                    return Intl.DateTimeFormat('en-US').format(relatedAt);\n                }}\n            />\n        </Table>\n    }\n    renderNone() {\n        return (\n            <p style={{ fontStyle: 'italic' }}>\n                No objects use this term.\n            </p>\n        )\n    }\n    render() {\n        if (this.props.linkedObjects.length === 0) {\n            return this.renderNone();\n        }\n        return this.renderTable();\n    }\n}","import React from 'react';\nimport LinkedObjectsDB, { LinkedObjectsDBStateLoaded } from './LinkedObjectsDB';\nimport { DBStatus, DBStateError } from '../../../../lib/DB';\n\nimport { AppConfig } from '@kbase/ui-components';\nimport View from './view';\nimport { OntologyReference } from '../../../../types/ontology';\nimport { Icon } from 'antd';\nimport ErrorView from '../../../../components/ErrorView';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    termRef: OntologyReference;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: LinkedObjectsDB;\n    constructor(props: Props) {\n        super(props);\n        this.db = new LinkedObjectsDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n    }\n\n    componentDidMount() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                this.db.getLinkedObjects(this.props.termRef);\n        }\n    }\n\n    renderLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderError(db: DBStateError) {\n        return <ErrorView error={db.error} />\n    }\n\n    renderLoaded(db: LinkedObjectsDBStateLoaded) {\n        return (\n            <View\n                linkedObjects={db.linkedObjects}\n            />\n        );\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                return this.renderLoading();\n            case DBStatus.LOADING:\n                return this.renderLoading();\n            case DBStatus.ERROR:\n                return this.renderError(db);\n            case DBStatus.LOADED:\n                return this.renderLoaded(db);\n        }\n    }\n}\n","import { AppConfig } from '@kbase/ui-components';\nimport { StoreState } from '../../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps { }\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps() {\n    return {};\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import DB, { DBProps, DBStatus, DBStateNone, DBStateLoading, DBStateLoaded, DBStateError } from '../../../lib/DB';\nimport { OntologyReference, OntologyRelatedTerm } from '../../../types/ontology';\nimport { AppConfig } from '@kbase/ui-components';\nimport OntologyModel from '../lib/model';\n\nexport type ParentsDBStateNone = DBStateNone;\nexport type ParentsDBStateLoading = DBStateLoading;\nexport type ParentsDBStateError = DBStateError;\nexport interface ParentsDBStateLoaded extends DBStateLoaded {\n    terms: Array<OntologyRelatedTerm>;\n}\n\nexport type ParentsDBState = ParentsDBStateNone | ParentsDBStateLoading | ParentsDBStateLoaded | ParentsDBStateError;\n\nexport interface ParentsDBProps extends DBProps<ParentsDBState> {\n    token: string;\n    config: AppConfig;\n}\n\nexport default class ParentsDB extends DB<ParentsDBState> {\n    props: ParentsDBProps;\n    constructor(props: ParentsDBProps) {\n        super(props);\n        this.props = props;\n    }\n\n    async getChildrenTerms(termRef: OntologyReference) {\n        this.set((state: ParentsDBState) => {\n            return {\n                ...state,\n                status: DBStatus.LOADING\n            };\n        });\n\n        const client = new OntologyModel({\n            token: this.props.token,\n            url: this.props.config.services.ServiceWizard.url\n        });\n\n        try {\n\n            const { terms } = await client.getChildren({\n                ref: termRef\n            });\n\n            terms.sort((a: OntologyRelatedTerm, b: OntologyRelatedTerm) => {\n                return a.term.name.localeCompare(b.term.name);\n            });\n\n            this.set((state: ParentsDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    terms: terms\n                }\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: ParentsDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.ERROR,\n                    error: ex.message\n                };\n            });\n        }\n    }\n\n}","import React from 'react';\nimport { OntologyRelatedTerm, OntologyRelation } from '../../../types/ontology';\nimport './style.css';\nimport { Empty, Table, Tooltip } from 'antd';\nimport Column from 'antd/lib/table/Column';\nimport { relationToString } from '../lib/model';\n\nexport interface Props {\n    terms: Array<OntologyRelatedTerm>;\n}\n\ninterface State { }\n\nexport default class OntologyList extends React.Component<Props, State> {\n    renderRelation(relation: OntologyRelation) {\n        return relationToString(relation);\n\n    }\n    renderItemsTable() {\n        return <Table<OntologyRelatedTerm>\n            dataSource={this.props.terms}\n            className=\"KBaseAntdOverride-remove-table-border ScrollingFlexTable\"\n            size=\"small\"\n            pagination={false}\n            rowKey={(row: OntologyRelatedTerm) => {\n                return row.term.ref.id;\n            }}\n            scroll={{ y: '100%' }}\n        >\n            <Column dataIndex='term.name' title=\"Name\" width=\"60%\" />\n            <Column dataIndex=\"term.goID\" title=\"ID\" width=\"20%\"\n                render={(id: string, term: OntologyRelatedTerm) => {\n                    const tooltip = (\n                        <div>\n                            {term.term.name}<br />\n                            {term.term.goID}\n                            <hr />\n                            {term.term.definition}\n                        </div>\n                    )\n                    // TODO: fix the hard coded url below!\n                    return (\n                        <Tooltip title={tooltip} placement=\"left\">\n                            <a href={`/#review/go_ontology/${id}/${term.term.ref.timestamp}`} target=\"_parent\">\n                                {id}\n                            </a>\n                        </Tooltip>\n                    )\n                }} />\n            <Column dataIndex=\"relation\" title=\"Relation\" width=\"20%\"\n                render={(relation: OntologyRelation) => {\n                    return this.renderRelation(relation);\n                }} />\n        </Table>\n    }\n    renderNoItems() {\n        return <Empty description=\"No Children\" image={Empty.PRESENTED_IMAGE_SIMPLE} />;\n    }\n    render() {\n        if (this.props.terms.length === 0) {\n            return this.renderNoItems();\n        }\n        return this.renderItemsTable();\n    }\n}\n","import React from 'react';\nimport ParentsDB, { ParentsDBStateLoaded } from './ChildrenDB';\nimport { DBStatus, DBStateError } from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport View from './view';\nimport { Icon } from 'antd';\nimport ErrorView from '../../../components/ErrorView';\nimport { OntologyReference } from '../../../types/ontology';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    termRef: OntologyReference;\n    // navigateToTermRef: (termRef: OntologyReference) => void;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: ParentsDB;\n    currentlyNavigatedOntologyRef: OntologyReference | null;\n    constructor(props: Props) {\n        super(props);\n        this.db = new ParentsDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n        this.currentlyNavigatedOntologyRef = null;\n    }\n\n    // selectTerm(termRef: OntologyReference) {\n    //     return this.db.getSelectedTerm(termRef);\n    // }\n\n    // navigateToTerm(termRef: OntologyReference) {\n    //     return this.props.navigateToTermRef(termRef);\n    // }\n\n    renderLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderError(db: DBStateError) {\n        // NB this is rendered raw in the container, which is a flex row.\n        return (\n            <div className=\"Col\">\n                <div style={{ width: '50%', margin: '20px auto 0 auto' }}>\n                    <ErrorView error={db.error} />\n                </div>\n            </div>\n        );\n    }\n\n    renderLoaded(db: ParentsDBStateLoaded) {\n        return (\n            <View\n                terms={db.terms}\n            />\n        );\n    }\n\n    componentDidMount() {\n        this.db.getChildrenTerms(this.props.termRef);\n    }\n\n    componentDidUpdate(previousProps: Props) {\n        // if (previousProps.termRef.id !== this.props.termRef.id ||\n        //     previousProps.termRef.timestamp !== this.props.termRef.timestamp) {\n        //     this.db.getTargetTerm(this.props.termRef);\n        // }\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                // this.db.getTargetTaxon(this.props.taxonID);\n                return this.renderLoading();\n            case DBStatus.LOADING:\n                return this.renderLoading();\n            case DBStatus.ERROR:\n                return this.renderError(db);\n            case DBStatus.LOADED:\n                return this.renderLoaded(db);\n            // if (this.props.taxonID !== db.targetTaxon.id) {\n            //     this.db.getTargetTaxon(this.props.taxonID);\n            //     return this.renderLoaded(db);\n            // } else {\n            //     return this.renderLoaded(db);\n            // }\n        }\n    }\n}\n","import { AppConfig, sendTitle } from '@kbase/ui-components';\nimport { StoreState } from '../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { navigate } from '../../../redux/actions';\nimport { OntologyReference } from '../../../types/ontology';\nimport { ontologyReferenceToNamespace } from '../lib/model';\n\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps {\n    navigate: (ref: OntologyReference) => void;\n    setTitle: (title: string) => void;\n}\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, props: OwnProps): DispatchProps {\n    return {\n        navigate: (ref: OntologyReference) => {\n            const relationEngineID = [\n                ontologyReferenceToNamespace(ref),\n                ref.id,\n                String(ref.timestamp)\n            ].join('/');\n            dispatch(navigate(relationEngineID) as any);\n        },\n        setTitle: (title: string) => {\n            dispatch(sendTitle(title) as any);\n        }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import DB, { DBProps, DBStatus, DBStateNone, DBStateLoading, DBStateLoaded, DBStateError } from '../../../lib/DB';\nimport { OntologyReference, OntologyTerm } from '../../../types/ontology';\nimport { AppConfig } from '@kbase/ui-components';\nimport OntologyModel, { TermsGraph, TermsGraphNode } from '../lib/model';\n\nexport type AncestorGraphDBStateNone = DBStateNone;\nexport type AncestorGraphDBStateLoading = DBStateLoading;\nexport type AncestorGraphDBStateError = DBStateError;\nexport interface AncestorGraphDBStateLoaded extends DBStateLoaded {\n    graph: TermsGraph;\n    term: OntologyTerm;\n}\n\nexport type AncestorGraphDBState = AncestorGraphDBStateNone | AncestorGraphDBStateLoading | AncestorGraphDBStateLoaded | AncestorGraphDBStateError;\n\nexport interface AncestorGraphDBProps extends DBProps<AncestorGraphDBState> {\n    token: string;\n    config: AppConfig;\n}\n\nexport default class AncestorGraphDB extends DB<AncestorGraphDBState> {\n    props: AncestorGraphDBProps;\n    constructor(props: AncestorGraphDBProps) {\n        super(props);\n        this.props = props;\n    }\n\n    async getAncestorGraph(termRef: OntologyReference) {\n        this.set((state: AncestorGraphDBState) => {\n            return {\n                ...state,\n                status: DBStatus.LOADING\n            };\n        });\n\n        const client = new OntologyModel({\n            token: this.props.token,\n            url: this.props.config.services.ServiceWizard.url\n        });\n\n        try {\n\n            const { term } = await client.getTerm({\n                ref: termRef\n            })\n\n            const { termsGraph } = await client.getAncestorGraph({\n                ref: termRef\n            });\n\n            const node: TermsGraphNode = {\n                id: term.ref.id,\n                isRoot: false,\n                term: term\n            };\n            termsGraph.terms.push(node);\n\n            this.set((state: AncestorGraphDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.LOADED,\n                    graph: termsGraph,\n                    term\n                }\n            });\n        } catch (ex) {\n            console.error('ERROR', ex);\n            this.set((state: AncestorGraphDBState) => {\n                return {\n                    ...state,\n                    status: DBStatus.ERROR,\n                    error: {\n                        code: 'error',\n                        source: 'ancestor-graph-data-fetch',\n                        message: ex.message\n                    }\n                };\n            });\n        }\n    }\n\n}","import React from 'react';\nimport { Network, Node, DataSet, Edge, Options } from 'vis-network';\nimport './NetworkGraph.css';\n\nexport interface NetworkNode {\n    id: string;\n    label: string;\n    isTerm: boolean;\n    isRoot: boolean;\n    isSelected: boolean;\n}\nexport interface NetworkEdge {\n    from: string;\n    to: string;\n    label: string;\n}\n\nexport interface NetworkData {\n    nodes: Array<NetworkNode>;\n    edges: Array<NetworkEdge>;\n}\n\nexport interface NetworkGraphProps {\n    data: NetworkData;\n    selectedNodeID: string | null;\n    height: string;\n    selectNodeID: (nodeID: string) => void;\n}\n\ninterface NetworkGraphState {\n}\n\nexport default class NetworkGraph extends React.Component<NetworkGraphProps, NetworkGraphState> {\n    networkGraphNode: React.RefObject<HTMLDivElement>;\n    graphNode: React.RefObject<HTMLDivElement>;\n    network?: Network;\n    constructor(props: NetworkGraphProps) {\n        super(props);\n        this.graphNode = React.createRef();\n        this.networkGraphNode = React.createRef();\n    }\n\n    mountGraph() {\n        if (this.graphNode.current === null) {\n            return;\n        }\n        const nodes = new DataSet<Node, 'id'>({});\n        nodes.add(this.props.data.nodes.map((term) => {\n            let color: string;\n            if (term.isTerm) {\n                color = 'red';\n            } else {\n                color = 'black';\n            }\n            if (term.isRoot) {\n                color = 'green';\n            }\n            return {\n                id: term.id,\n                label: term.label,\n                color: {\n                    border: color\n                },\n                shape: term.isRoot || term.isTerm ? 'ellipse' : 'box',\n                // fixed: term.isTerm || term.isRoot,\n                // y: term.isTerm ? 800 : (term.isRoot ? 0 : undefined)\n            }\n        }));\n        const edges = new DataSet<Edge, 'id'>({});\n        edges.add(this.props.data.edges.map((e) => {\n            return {\n                from: e.from,\n                to: e.to,\n                arrows: 'to',\n                label: e.label\n            };\n        }));\n\n\n        const graphHeight = '400px';\n        const options: Options = {\n            layout: {\n                hierarchical: {\n                    enabled: true,\n                    direction: 'DU',\n                    sortMethod: 'directed',\n                    nodeSpacing: 300\n                }\n            },\n            physics: false,\n            height: graphHeight,\n            // autoResize: true,\n            // width: '100%',\n            // height: '100%'\n            nodes: {\n                color: {\n                    highlight: {\n                        border: 'blue',\n                        background: 'rgb(204, 255, 255, 1)'\n                    }\n                },\n                margin: {\n                    top: 10,\n                    right: 10,\n                    bottom: 10,\n                    left: 10\n                }\n            }\n        }\n\n\n        this.network = new Network(this.graphNode.current, { nodes, edges }, options);\n        this.network.on('selectNode', ({ nodes: [nodeID] }) => {\n            this.props.selectNodeID(nodeID);\n        });\n        if (this.props.selectedNodeID) {\n            this.network.selectNodes([this.props.selectedNodeID])\n        }\n    }\n\n    componentDidMount() {\n        this.mountGraph();\n\n        window.addEventListener('resize', () => {\n            this.onResize();\n        });\n        this.onResize();\n    }\n\n    onResize() {\n        let graphHeight: string;\n        if (this.networkGraphNode.current) {\n            graphHeight = this.networkGraphNode.current.clientHeight + 'px';\n        } else {\n            graphHeight = '400px';\n        }\n        if (this.network) {\n            this.network.setSize('100%', graphHeight);\n            this.network.redraw();\n        }\n    }\n\n    componentDidUpdate() {\n        if (this.props.selectedNodeID && this.network) {\n            this.network.selectNodes([this.props.selectedNodeID])\n        }\n    }\n\n    render() {\n        return <div ref={this.networkGraphNode} className=\"NetworkGraph\">\n            <div ref={this.graphNode} className=\"NetworkGraph-graphWrapper\">\n\n            </div>\n        </div>\n    }\n}","import React from 'react';\nimport { TermsGraph, relationToString, TermsGraphNode, ontologyReferenceToNamespace } from '../lib/model';\nimport NetworkGraph, { NetworkData } from './NetworkGraph';\nimport { OntologyTerm } from '../../../types/ontology';\nimport './style.css';\nimport { Table } from 'antd';\n\nexport interface AncestorGraphProps {\n    term: OntologyTerm;\n    graph: TermsGraph\n}\n\ninterface AncestorGraphState {\n    selectedNodeID: string | null;\n}\n\nexport default class AncestorGraph extends React.Component<AncestorGraphProps, AncestorGraphState> {\n    constructor(props: AncestorGraphProps) {\n        super(props);\n        this.state = {\n            selectedNodeID: null\n        };\n    }\n    selectGraphNode(termNode: TermsGraphNode) {\n        this.setState({\n            selectedNodeID: termNode.term.ref.id\n        })\n    }\n    renderTable() {\n        return <Table\n            dataSource={this.props.graph.terms}\n            size=\"small\"\n            pagination={false}\n            scroll={{ y: '100%' }}\n            className=\"KBaseAntdOverride-remove-table-border ScrollingFlexTable\"\n            rowSelection={{\n                // onSelect: (termNode: TermsGraphNode) => {\n                //     this.selectGraphNode(termNode)\n                // }\n                type: 'radio',\n                fixed: false,\n                hideDefaultSelections: true,\n                selectedRowKeys: this.state.selectedNodeID ? [this.state.selectedNodeID] : []\n            }}\n            rowKey={(node: TermsGraphNode) => {\n                return node.id;\n            }}>\n\n            <Table.Column dataIndex=\"term\"\n                defaultSortOrder=\"ascend\"\n                sorter={(a: TermsGraphNode, b: TermsGraphNode) => {\n                    return a.term.name.localeCompare(b.term.name);\n                }}\n                key=\"term.id\"\n                title=\"Name\"\n                width=\"85%\"\n                render={(term: OntologyTerm, termNode: TermsGraphNode) => {\n                    return <span\n                        style={{ cursor: 'pointer' }}\n                        onClick={() => {\n                            this.selectGraphNode(termNode)\n                        }}>\n                        {term.name}\n                    </span>\n                }}\n            />\n\n            < Table.Column dataIndex=\"term\"\n                sorter={(a: TermsGraphNode, b: TermsGraphNode) => {\n                    return a.term.name.localeCompare(b.term.name);\n                }}\n                title=\"ID\"\n                width=\"15%\"\n\n                render={(term: OntologyTerm) => {\n                    const url = [\n                        '/#review',\n                        ontologyReferenceToNamespace(term.ref),\n                        term.ref.id\n                    ].join('/');\n                    return (\n                        <a href={url} target=\"_parent\">{term.ref.id}</a>\n                    )\n                }} />\n\n        </Table>\n    }\n    selectNodeID(nodeID: string) {\n        this.setState({\n            selectedNodeID: nodeID\n        });\n    }\n    render() {\n        const nodes = this.props.graph.terms.map((termNode) => {\n            const isTerm = termNode.id === this.props.term.ref.id;\n            return {\n                id: termNode.id,\n                label: termNode.term.name,\n                isTerm: isTerm,\n                isRoot: termNode.isRoot,\n                isSelected: termNode.term.ref.id === this.state.selectedNodeID\n            }\n        });\n        // Here we add the term of focus to the graph.\n        // TODO: this should be done in the data layer.\n        // nodes.push({\n        //     id: this.props.term.ref.id,\n        //     label: this.props.term.name,\n        //     isTerm: true,\n        //     isRoot: false,\n        //     isSelected: false\n        // })\n        const edges = this.props.graph.relations.map((relation) => {\n            return {\n                from: relation.from,\n                to: relation.to,\n                label: relationToString(relation.relation)\n            }\n        })\n        const data: NetworkData = {\n            nodes,\n            edges\n        }\n        return (\n            <div className=\"AncestorGraph\">\n                <div className=\"AncestorGraph-graph\">\n                    <NetworkGraph\n                        data={data}\n                        height=\"400px\"\n                        selectedNodeID={this.state.selectedNodeID}\n                        selectNodeID={this.selectNodeID.bind(this)} />\n                </div>\n                <div className=\"AncestorGraph-table\">\n                    {this.renderTable()}\n                </div>\n            </div>\n        )\n    }\n\n}","import React from 'react';\nimport AncestorGraphDB, { AncestorGraphDBStateLoaded } from './AncestorGraphDB';\nimport { DBStatus, DBStateError } from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport View from './view';\nimport { Icon } from 'antd';\nimport ErrorView from '../../../components/ErrorView';\nimport { OntologyReference } from '../../../types/ontology';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    termRef: OntologyReference;\n    // navigateToTermRef: (termRef: OntologyReference) => void;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: AncestorGraphDB;\n    currentlyNavigatedOntologyRef: OntologyReference | null;\n    constructor(props: Props) {\n        super(props);\n        this.db = new AncestorGraphDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n        this.currentlyNavigatedOntologyRef = null;\n    }\n\n    // selectTerm(termRef: OntologyReference) {\n    //     return this.db.getSelectedTerm(termRef);\n    // }\n\n    // navigateToTerm(termRef: OntologyReference) {\n    //     return this.props.navigateToTermRef(termRef);\n    // }\n\n    renderLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderError(db: DBStateError) {\n        // NB this is rendered raw in the container, which is a flex row.\n        return (\n            <div className=\"Col\">\n                <div style={{ width: '50%', margin: '20px auto 0 auto' }}>\n                    <ErrorView error={db.error} />\n                </div>\n            </div>\n        );\n    }\n\n    renderLoaded(db: AncestorGraphDBStateLoaded) {\n        return (\n            <View\n                graph={db.graph} term={db.term}\n            />\n        );\n    }\n\n    componentDidMount() {\n        this.db.getAncestorGraph(this.props.termRef);\n    }\n\n    componentDidUpdate(previousProps: Props) {\n        // if (previousProps.termRef.id !== this.props.termRef.id ||\n        //     previousProps.termRef.timestamp !== this.props.termRef.timestamp) {\n        //     this.db.getTargetTerm(this.props.termRef);\n        // }\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                // this.db.getTargetTaxon(this.props.taxonID);\n                return this.renderLoading();\n            case DBStatus.LOADING:\n                return this.renderLoading();\n            case DBStatus.ERROR:\n                return this.renderError(db);\n            case DBStatus.LOADED:\n                return this.renderLoaded(db);\n            // if (this.props.taxonID !== db.targetTaxon.id) {\n            //     this.db.getTargetTaxon(this.props.taxonID);\n            //     return this.renderLoaded(db);\n            // } else {\n            //     return this.renderLoaded(db);\n            // }\n        }\n    }\n}\n","import { AppConfig, sendTitle } from '@kbase/ui-components';\nimport { StoreState } from '../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { navigate } from '../../../redux/actions';\nimport { OntologyReference } from '../../../types/ontology';\nimport { ontologyReferenceToNamespace } from '../lib/model';\n\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps {\n    navigate: (ref: OntologyReference) => void;\n    setTitle: (title: string) => void;\n}\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, props: OwnProps): DispatchProps {\n    return {\n        navigate: (ref: OntologyReference) => {\n            const relationEngineID = [\n                ontologyReferenceToNamespace(ref),\n                ref.id,\n                String(ref.timestamp)\n            ].join('/');\n            dispatch(navigate(relationEngineID) as any);\n        },\n        setTitle: (title: string) => {\n            dispatch(sendTitle(title) as any);\n        }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import React from 'react';\nimport { FlexTabs } from '@kbase/ui-components';\nimport './style.css';\nimport { OntologyTerm, Synonym } from '../../../types/ontology';\nimport TermLink from '../TermLink';\nimport LinkedObjects from './LinkedObjects';\nimport Children from '../Children';\nimport AncestorGraph from '../AncestorGraph';\n\nexport interface DetailProps {\n    term: OntologyTerm\n}\n\ninterface DetailState {\n}\n\nexport default class Detail extends React.Component<DetailProps, DetailState> {\n    renderSynonyms(synonyms: Array<Synonym>) {\n        if (synonyms.length === 0) {\n            return <i>-</i>;\n        }\n        return synonyms.map((s, index) => {\n            return (\n                <div key={String(index)}>\n                    {s}\n                </div>\n            )\n        });\n    }\n\n    renderComments() {\n        if (this.props.term.comments.length === 0) {\n            return <i>-</i>;\n        }\n\n        return this.props.term.comments.map((comment, index) => {\n            const comments = comment.split('\\n');\n            return comments.map((comment, index2) => {\n                return <p key={String(index) + '-' + String(index2)}>{comment}</p>\n            });\n        });\n    }\n\n    renderDetail() {\n        return (\n            <div className=\"InfoTable DetailTable\">\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        ID\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        <TermLink term={this.props.term} newWindow={true} />\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        Name\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.props.term.name}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        Definition\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.props.term.definition}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        Comments\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.renderComments()}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        synonyms\n                </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.renderAllSynonyms()}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n    renderAllSynonyms() {\n        return (\n            <div className=\"InfoTable DetailTable\">\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        exact\n                        </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.renderSynonyms(this.props.term.synonyms.exact)}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        narrow\n                                </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.renderSynonyms(this.props.term.synonyms.narrow)}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        broad\n                                </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.renderSynonyms(this.props.term.synonyms.broad)}\n                    </div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\">\n                        related\n                                </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.renderSynonyms(this.props.term.synonyms.broad)}\n                    </div>\n                </div>\n            </div>\n        )\n    }\n    renderGraph() {\n        return (\n            <AncestorGraph termRef={this.props.term.ref} />\n        )\n    }\n    renderLinkedObjects() {\n\n        return (\n            <LinkedObjects termRef={this.props.term.ref} />\n        )\n    }\n    renderMetadata() {\n        return (\n            <div>\n                render metadata here...\n            </div>\n        )\n    }\n    renderChildren() {\n        return <Children\n            termRef={this.props.term.ref}\n        />\n    }\n\n    render() {\n        const tabs = [\n            {\n                tab: 'graph',\n                title: 'Graph',\n                component: this.renderGraph()\n            },\n            {\n                tab: 'detail',\n                title: 'Detail',\n                component: this.renderDetail()\n            },\n            {\n                tab: 'synonyms',\n                title: 'Synonyms',\n                component: this.renderAllSynonyms()\n            },\n            {\n                tab: 'children',\n                title: 'Children',\n                component: this.renderChildren()\n            },\n            {\n                tab: 'linked',\n                title: 'Linked Data',\n                component: this.renderLinkedObjects()\n            },\n            // {\n            //     tab: 'metadata',\n            //     title: 'Metadata',\n            //     component: this.renderMetadata()\n            // }\n        ]\n        return (\n            <FlexTabs tabs={tabs} />\n        )\n    }\n}","import React from 'react';\n\nexport interface Props {\n\n}\n\ninterface State {\n\n}\n\nexport default class SourceInfo extends React.Component<Props, State> {\n    render() {\n        return (\n            <div className=\"Row\">\n                <div className=\"Col-auto\" style={{ justifyContent: 'center' }}>\n                    <img src=\"images/go-logo.png\" style={{ height: '50px' }} alt=\"Gene Ontology Logo\" />\n                </div>\n                <div className=\"Col\">\n                    <div className=\"InfoTable\">\n                        <div className=\"InfoTable-row\">\n                            <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                                Source\n                            </div>\n                            <div className=\"InfoTable-dataCol\">\n                                <a\n                                    href=\"http://geneontology.org/\"\n                                    target=\"_blank\"\n                                    rel=\"noopener noreferrer\"\n                                >\n                                    Gene Ontology (GO)\n                                </a>\n                            </div>\n                        </div>\n                        <div className=\"InfoTable-row\">\n                            <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                                Version\n                            </div>\n                            <div className=\"InfoTable-dataCol\">SOME VERSION</div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n}","import React from 'react';\nimport { OntologyTerm } from '../../../types/ontology';\n\nexport interface Props {\n    term: OntologyTerm\n}\n\ninterface State {\n\n}\n\nexport default class TermSummary extends React.Component<Props, State> {\n    render() {\n        return (\n            <div className=\"InfoTable\">\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                        ID\n                    </div>\n                    <div className=\"InfoTable-dataCol\">{this.props.term.goID}</div>\n                </div>\n                <div className=\"InfoTable-row\">\n                    <div className=\"InfoTable-labelCol\" style={{ width: '5em' }}>\n                        Name\n                    </div>\n                    <div className=\"InfoTable-dataCol\">\n                        {this.props.term.name}\n                    </div>\n                </div>\n\n            </div>\n        );\n    }\n\n}","import React from 'react';\nimport { OntologyReference, OntologyTerm } from '../../../types/ontology';\nimport './style.css';\nimport Detail from '../Detail';\nimport { Row, Col } from 'antd';\nimport SourceInfo from './SourceInfo';\nimport TermSummary from './TermSummary';\n\nexport interface Props {\n    // termRef: OntologyReference;\n    targetTerm: OntologyTerm;\n    selectedTerm: OntologyTerm;\n    selectTerm: (termRef: OntologyReference) => void;\n    navigate: (termRef: OntologyReference) => void;\n    setTitle: (title: string) => void;\n}\n\ninterface State { }\n\nexport default class OntologyView extends React.Component<Props, State> {\n    componentDidMount() {\n        this.props.setTitle(`Ontology Landing Page for \"${this.props.targetTerm.name}\" (${this.props.targetTerm.goID})`);\n    }\n\n    renderLayout() {\n        return (\n            <div className=\"Col scrollable Taxonomy\">\n                <div className=\"Col-auto Ontology-summary-section\">\n                    <Row>\n                        <Col span={12}>\n                            <TermSummary term={this.props.targetTerm} />\n                        </Col>\n                        <Col span={12}>\n                            <SourceInfo />\n                        </Col>\n                    </Row>\n                </div>\n                <div className=\"Row scrollable\">\n\n                    <div className=\"Col scrollable\" >\n                        <Detail term={this.props.selectedTerm} />\n                    </div>\n                </div>\n            </div>\n        )\n    }\n\n    render() {\n        return this.renderLayout();\n    }\n}\n","import React from 'react';\nimport OntologyDB, { OntologyDBStateLoaded } from './OntologyDB';\nimport { DBStatus, DBStateError } from '../../../lib/DB';\nimport { AppConfig } from '@kbase/ui-components';\nimport View from './view';\nimport { Icon } from 'antd';\nimport ErrorView from '../../../components/ErrorView';\nimport { OntologyReference } from '../../../types/ontology';\n\nexport interface Props {\n    token: string;\n    config: AppConfig;\n    termRef: OntologyReference;\n    // taxonID: TaxonID;\n    navigate: (termRef: OntologyReference) => void;\n    setTitle: (title: string) => void;\n}\n\ninterface State { }\n\nexport default class Data extends React.Component<Props, State> {\n    db: OntologyDB;\n    currentlyNavigatedOntologyRef: OntologyReference | null;\n    constructor(props: Props) {\n        super(props);\n        this.db = new OntologyDB({\n            onUpdate: () => {\n                this.forceUpdate();\n            },\n            initialData: {\n                status: DBStatus.NONE\n            },\n            token: props.token,\n            config: props.config\n        });\n        this.currentlyNavigatedOntologyRef = null;\n    }\n\n    selectTerm(termRef: OntologyReference) {\n        return this.db.setSelectedTerm(termRef);\n    }\n\n    navigateToTerm(termRef: OntologyReference) {\n        return this.props.navigate(termRef);\n    }\n\n    renderLoading() {\n        return <Icon type=\"loading\" />;\n    }\n\n    renderError(db: DBStateError) {\n        // NB this is rendered raw in the container, which is a flex row.\n        return (\n            <div className=\"Col\">\n                <div style={{ width: '50%', margin: '20px auto 0 auto' }}>\n                    <ErrorView error={db.error} />\n                </div>\n            </div>\n        );\n    }\n\n    renderLoaded(db: OntologyDBStateLoaded) {\n        return (\n            <View\n                targetTerm={db.targetTerm}\n                selectedTerm={db.selectedTerm}\n                selectTerm={this.selectTerm.bind(this)}\n                navigate={this.navigateToTerm.bind(this)}\n                setTitle={this.props.setTitle}\n            />\n        );\n    }\n\n    componentDidMount() {\n        this.db.getTargetTerm(this.props.termRef);\n    }\n\n    componentDidUpdate(previousProps: Props) {\n        if (previousProps.termRef.id !== this.props.termRef.id ||\n            previousProps.termRef.timestamp !== this.props.termRef.timestamp) {\n            this.db.getTargetTerm(this.props.termRef);\n        }\n    }\n\n    render() {\n        const db = this.db.get();\n        switch (db.status) {\n            case DBStatus.NONE:\n                // this.db.getTargetTaxon(this.props.taxonID);\n                return this.renderLoading();\n            case DBStatus.LOADING:\n                return this.renderLoading();\n            case DBStatus.ERROR:\n                return this.renderError(db);\n            case DBStatus.LOADED:\n                return this.renderLoaded(db);\n            // if (this.props.taxonID !== db.targetTaxon.id) {\n            //     this.db.getTargetTaxon(this.props.taxonID);\n            //     return this.renderLoaded(db);\n            // } else {\n            //     return this.renderLoaded(db);\n            // }\n        }\n    }\n}\n","import { AppConfig, sendTitle } from '@kbase/ui-components';\nimport { StoreState } from '../../../redux/store';\nimport DataComponent from './data';\nimport { connect } from 'react-redux';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { navigate } from '../../../redux/actions';\nimport { OntologyReference } from '../../../types/ontology';\nimport { ontologyReferenceToNamespace } from '../lib/model';\n\n\nexport interface OwnProps { }\n\nexport interface StateProps {\n    token: string;\n    config: AppConfig;\n}\n\nexport interface DispatchProps {\n    navigate: (ref: OntologyReference) => void;\n    setTitle: (title: string) => void;\n}\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        app: { config }\n    } = state;\n    if (!userAuthorization) {\n        throw new Error('Invalid state - no user authorization');\n    }\n    return {\n        token: userAuthorization.token,\n        config\n    };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, props: OwnProps): DispatchProps {\n    return {\n        navigate: (ref: OntologyReference) => {\n            const relationEngineID = [\n                ontologyReferenceToNamespace(ref),\n                ref.id,\n                String(ref.timestamp)\n            ].join('/');\n            dispatch(navigate(relationEngineID) as any);\n        },\n        setTitle: (title: string) => {\n            dispatch(sendTitle(title) as any);\n        }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(DataComponent);\n","import { RelationEngineID, StoreState } from '../../redux/store';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { navigate } from '../../redux/actions';\nimport { connect } from 'react-redux';\nimport Main from './Main';\nimport { sendTitle } from '@kbase/ui-components';\n\nexport interface OwnProps {\n}\n\nexport interface StateProps {\n}\n\nexport interface DispatchProps {\n    navigate: (relationEngineID: RelationEngineID) => void;\n    setTitle: (title: string) => void;\n}\n\nfunction mapStateToProps(state: StoreState, ownProps: OwnProps): StateProps {\n    return {};\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, ownProps: OwnProps): DispatchProps {\n    return {\n        navigate: (relationEngineId: RelationEngineID) => {\n            dispatch(navigate(relationEngineId) as any);\n        },\n        setTitle: (title: string) => {\n            dispatch(sendTitle(title) as any);\n        }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(Main);\n","import React from 'react';\nimport { RootState } from '@kbase/ui-components';\nimport {\n    RelationEngineID,\n    Navigation,\n    NavigationSome\n} from '../../redux/store';\nimport { ViewType } from '../../redux/store/view';\nimport Taxonomy from '../../landingPages/taxonomy';\nimport OntologyView from '../../landingPages/ontology';\n\nexport interface DispatcherProps {\n    token: string | null;\n    rootState: RootState;\n    navigation: Navigation;\n    trigger: number;\n    navigate: (relationEngineID: RelationEngineID) => void;\n}\n\ninterface DispatcherState { }\n\nexport class Dispatcher extends React.Component<DispatcherProps, DispatcherState> {\n    renderUnauthorized() {\n        return <div>Sorry, not authorized. Please log in first.</div>;\n    }\n\n    renderRootState() {\n        switch (this.props.rootState) {\n            case RootState.NONE:\n                return '';\n            case RootState.HOSTED:\n                return '';\n            case RootState.DEVELOP:\n                return '';\n            case RootState.ERROR:\n                return 'error';\n        }\n    }\n\n    renderNavigationNone() {\n        return <div>none</div>;\n    }\n\n    renderNavigationSome(navigation: NavigationSome) {\n        // This is currently how we dispatch to the type-specific\n        // landing page.\n        switch (navigation.type) {\n            case ViewType.TAXONOMY:\n                return <Taxonomy taxonRef={navigation.ref} />;\n            case ViewType.ONTOLOGY:\n                return <OntologyView termRef={navigation.ref} />;\n            default:\n                // TODO: make real error display.\n                console.error('Unhandled navigation', navigation);\n        }\n    }\n\n    renderNavigation() {\n        switch (this.props.navigation.type) {\n            case ViewType.NONE:\n                return this.renderNavigationNone();\n            default:\n                return this.renderNavigationSome(this.props.navigation);\n            // case ViewStatus.LOADING:\n            //     return this.renderNavigationLoading(this.props.view);\n            // case ViewStatus.LOADED:\n            //     return this.renderNavigationLoaded(this.props.view);\n            // case ViewStatus.ERROR:\n            //     return this.renderNavigationError(this.props.view);\n        }\n    }\n\n    parseHash(hash: string): { path: Array<string>; params: { relationEngineID: string } } {\n        const hashRe = /^#(.*?)\\/(.*)$/;\n        const m = hashRe.exec(hash);\n\n        if (!m) {\n            throw new Error('Invalid path');\n        }\n\n        // Just for now...\n        // TODO: for real\n\n        const [, path, relationEngineID] = m;\n\n        return {\n            path: [path],\n            params: { relationEngineID }\n        };\n    }\n\n    componentDidMount() {\n        if (this.props.rootState === RootState.DEVELOP) {\n            // Navigate on change of the hash\n            window.addEventListener('hashchange', (ev: HashChangeEvent) => {\n                const url = new URL(ev.newURL);\n                const hash = url.hash;\n                if (!hash) {\n                    throw new Error('no hash!');\n                }\n                const {\n                    params: { relationEngineID }\n                } = this.parseHash(hash);\n                this.props.navigate(relationEngineID);\n            });\n\n            // First time here, we also want to navigate based on the\n            // hash, or if empty (the default when a dev session starts)\n            // use some default interesting taxon id.\n            const hash = window.location.hash;\n            if (hash) {\n                const {\n                    params: { relationEngineID }\n                } = this.parseHash(hash);\n                this.props.navigate(relationEngineID);\n            } else {\n                // TODO: remove?\n                // #review/ontology/go/GO:0007610\n                // this.props.navigate('ncbi_taxonomy/562');\n                this.props.navigate('go_ontology/GO:0007610');\n            }\n        }\n    }\n\n    render() {\n        if (!this.props.token) {\n            return this.renderUnauthorized();\n        }\n        return (\n            <div className=\"Col scrollable\">\n                <div className=\"Row-auto\">{this.renderRootState()}</div>\n                <div className=\"Row  scrollable\">{this.renderNavigation()}</div>\n            </div>\n        );\n    }\n}\n","import { StoreState, RelationEngineID, Navigation } from '../../redux/store';\nimport { Dispatch } from 'react';\nimport { Action } from 'redux';\nimport { connect } from 'react-redux';\nimport { Dispatcher } from './Dispatcher';\nimport { RootState } from '@kbase/ui-components';\nimport { navigate } from '../../redux/actions';\n\ninterface OwnProps { }\n\ninterface StateProps {\n    token: string | null;\n    rootState: RootState;\n    navigation: Navigation;\n    trigger: number;\n}\n\ninterface DispatchProps {\n    navigate: (relationEngineID: RelationEngineID) => void;\n    // view: (view: View) => void;\n}\n\nfunction mapStateToProps(state: StoreState, props: OwnProps): StateProps {\n    const {\n        auth: { userAuthorization },\n        root: { state: rootState },\n        navigation,\n        trigger\n    } = state;\n\n    // Auth integration.\n    let token;\n    if (!userAuthorization) {\n        token = null;\n    } else {\n        token = userAuthorization.token;\n    }\n\n    return { token, rootState, navigation, trigger };\n}\n\nfunction mapDispatchToProps(dispatch: Dispatch<Action>, ownProps: OwnProps): DispatchProps {\n    return {\n        navigate: (relationEngineID: RelationEngineID) => {\n            dispatch(navigate(relationEngineID) as any);\n        },\n        // view: (view: View) => {\n        //     dispatch(view(view) as any)\n        // }\n    };\n}\n\nexport default connect<StateProps, DispatchProps, OwnProps, StoreState>(\n    mapStateToProps,\n    mapDispatchToProps\n)(Dispatcher);\n","import React from 'react';\nimport { Provider } from 'react-redux';\nimport { createReduxStore } from './redux/store';\nimport { AppBase, AuthGate } from '@kbase/ui-components';\nimport './App.css';\nimport Dispatcher from './components/dispatcher';\nimport { Unsubscribe } from 'redux';\nimport { navigate } from './redux/actions';\n\nconst store = createReduxStore();\n\ninterface AppProps { }\n\ninterface AppState { }\n\nexport default class App<AppProps, AppState> extends React.Component {\n    storeUnsubscribe: Unsubscribe | null;\n    constructor(props: AppProps) {\n        super(props);\n        this.storeUnsubscribe = null;\n    }\n    componentDidMount() {\n        let last: {\n            view: string | null;\n            params: { [key: string]: string };\n        } = {\n            view: null,\n            params: {}\n        };\n        this.storeUnsubscribe = store.subscribe(() => {\n            const state = store.getState();\n            if (!state) {\n                return;\n            }\n            const {\n                app: {\n                    runtime: { navigation }\n                },\n                auth: { userAuthorization }\n            } = state;\n\n            // This is a bit of a cheat.\n            if (!userAuthorization) {\n                return;\n            }\n\n            const view = navigation.view;\n            const params = navigation.params as { [key: string]: string };\n\n            if (\n                view !== last.view ||\n                last.params === null ||\n                Object.keys(params).some((key) => {\n                    return params[key] !== last.params[key];\n                })\n            ) {\n                last.params = params;\n                last.view = view;\n                // TODO: store may change but there is not navigation yet.\n                if (params['relationEngineID']) {\n                    store.dispatch(navigate(params['relationEngineID']) as any);\n                }\n            }\n        });\n    }\n    componentWillUnmount() {\n        if (this.storeUnsubscribe) {\n            this.storeUnsubscribe();\n        }\n    }\n    render() {\n        return (\n            <Provider store={store}>\n                <AppBase>\n                    <AuthGate required={true}>\n                        <div className=\"App Col scrollable\">\n                            <Dispatcher />\n                        </div>\n                    </AuthGate>\n                </AppBase>\n            </Provider>\n        );\n    }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}